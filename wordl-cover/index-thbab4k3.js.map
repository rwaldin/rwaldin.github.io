{
  "version": 3,
  "sources": ["../src/index.js"],
  "sourcesContent": ["const ios = /iPad|iPhone/.test(navigator.userAgent);\nconst availableConcurrency = 'hardwareConcurrency' in navigator ? navigator.hardwareConcurrency : ios ? 2 : 8;\n\nconst numberFormatter = new Intl.NumberFormat();\nconst numberFormat = number => numberFormatter.format(number);\nconst crlfRegex = /\\r?\\n/;\n\nconst { solutionsElem, solveFormElem, outputFormElem } = window;\n\nconst workers = Array.from({ length: availableConcurrency }, _ => {\n    const worker = new Worker('./worker.js');\n    worker.addEventListener('error', evt => solutionsElem.appendChild(document.createElement('li')).append(evt.toString()));\n    return worker;\n});\n\nconst {\n    customWordFile: customWordFileElem,\n    solveButton: solveButtonElem,\n    concurrency: concurrencyElem,\n    wordList: wordListRadio,\n} = solveFormElem;\n\nconst {\n    wordCount: wordCountElem,\n    fiveLetterWordCount: fiveLetterWordCountElem,\n    normalizedWordCount: normalizedWordCountElem,\n    solutionCount: solutionCountElem,\n    elapsedTime: elapsedTimeElem,\n    workItems: workItemsElem,\n    workersWorking: workersWorkingElem,\n} = outputFormElem;\n\nconst customWordListElem = [...wordListRadio].find(({ value }) => value === 'custom');\nconst wordlListElem = [...wordListRadio].find(({ value }) => value.match(/wordl/));\nconst wordsAlphaListElem = [...wordListRadio].find(({ value }) => value.match(/words_alpha/));\n\nfor (let n = 0; n < availableConcurrency; ++n) {\n    const option = document.createElement('option');\n    option.append(n + 1);\n    concurrencyElem.append(option);\n}\nconcurrencyElem.value = availableConcurrency;\n\ncustomWordFileElem.addEventListener('change', _ => (wordListRadio.value = 'custom'));\ncustomWordListElem.addEventListener('change', _ => {\n    if (wordListRadio.value === 'custom' && !customWordFileElem.value) {\n        customWordFileElem.click();\n    }\n});\n\nconst solve = wordsString => {\n    const startTime = Date.now();\n\n    solutionsElem.innerHTML = '';\n    solveButtonElem.innerText = 'Solving...';\n    solutionCountElem.innerText = 0;\n\n    const allWords = wordsString.split(crlfRegex).map(word => word.trim().toLowerCase());\n    wordCountElem.innerText = numberFormat(allWords.length);\n\n    const fiveLetterWords = allWords.filter(word => /^[a-z]{5}$/.test(word));\n    fiveLetterWordCountElem.innerText = numberFormat(fiveLetterWords.length);\n\n    // normalizedWords are fiveLetterWords with their letters rearranged so that they are sorted (WORDS becomes DORSW).\n    // Anagrams are removed from consideration by searching for normalizedWords instead of actual words since all anagrams\n    // map to the same normalizedWord.  Normalized words with any repeating characters are also removed.\n    const normalizedWordMap = new Map();\n    for (const word of fiveLetterWords) {\n        const normalizedWord = [...new Set(word)].sort().join('');\n        // ignore normalized words with repeating characters\n        if (normalizedWord.length === 5) {\n            const entry = normalizedWordMap.get(normalizedWord);\n            // combine anagrams for display later\n            normalizedWordMap.set(normalizedWord, entry ? `${entry}/${word}` : word);\n        }\n    }\n    normalizedWordCountElem.innerText = numberFormat(normalizedWordMap.size);\n\n    const words = [...normalizedWordMap.keys()];\n    const options = Object.fromEntries(words.map(word => [word, word.split('')]));\n\n    const a = 'a'.charCodeAt(0);\n    const allChars = Array.from({ length: 26 }, (_, i) => String.fromCharCode(a + i));\n    const usedChars = new Set(Object.values(options).flat());\n    if (usedChars.size !== 26) {\n        const missingChars = allChars.filter(char => !usedChars.includes(char));\n        solutionsElem.appendChild(document.createElement('li')).append(`Invalid word list. Missing letters: ${missingChars.join(', ')}`);\n        return;\n    }\n\n    const solutions = new Set();\n    const displaySolutions = [];\n\n    const workItems = allChars\n        .map(char => Object.fromEntries(Object.entries(options).filter(([word]) => !word.includes(char))))\n        // sort work in descending order of option count to reduce the time long-pole dangling workers require\n        .sort((workItem1, workItem2) => Object.keys(workItem2).length - Object.keys(workItem1).length);\n\n    const recordSolution = solution => {\n        // ignore solutions that contain the same normalized words as an already recorded solution, but in a different order\n        const normalizedSolution = solution.sort().join(',');\n        if (!solutions.has(normalizedSolution)) {\n            solutions.add(normalizedSolution);\n            displaySolutions.push(\n                normalizedSolution\n                    .split(',')\n                    .map(step => normalizedWordMap.get(step))\n                    .sort()\n                    .join(', ')\n            );\n        }\n    };\n\n    let currentWorkItem = 0;\n    let completedWorkItems = 0;\n\n    const renderInterval = setInterval(requestAnimationFrame, 60, _ => {\n        // append list elements for newly arrived solutions since last render\n        for (let i = solutionsElem.children.length; i < displaySolutions.length; ++i) {\n            solutionsElem.appendChild(document.createElement('li')).append(displaySolutions[i]);\n        }\n        solutionsElem.scrollTop = solutionsElem.scrollHeight;\n        solutionCountElem.innerText = numberFormat(solutions.size);\n        workItemsElem.value = workItems.length - completedWorkItems;\n        elapsedTimeElem.innerText = `${numberFormat((Date.now() - startTime) / 1000)} seconds`;\n    });\n\n    return new Promise(resolve => {\n        for (const [n, worker] of workers.entries()) {\n            if (n >= concurrencyElem.value) {\n                break;\n            }\n\n            const messageHandler = msg => {\n                switch (msg.data.type) {\n                    case 'solution': {\n                        recordSolution(msg.data.solution);\n                        break;\n                    }\n\n                    case 'completed': {\n                        ++completedWorkItems;\n                        if (currentWorkItem < workItems.length) {\n                            worker.postMessage({ type: 'solve', options: workItems[currentWorkItem++] });\n                        } else {\n                            workersWorkingElem.value -= 1;\n                            worker.removeEventListener('message', messageHandler);\n\n                            if (completedWorkItems === workItems.length) {\n                                solveButtonElem.disabled = false;\n                                solveButtonElem.innerText = 'Solve';\n                                elapsedTimeElem.innerText = `${numberFormat((Date.now() - startTime) / 1000)} seconds`;\n                                workItemsElem.value = 0;\n                                clearInterval(renderInterval);\n                                resolve();\n                            }\n                        }\n                        break;\n                    }\n                }\n            };\n\n            if (currentWorkItem < workItems.length) {\n                workersWorkingElem.value = n + 1;\n                worker.addEventListener('message', messageHandler);\n                worker.postMessage({ type: 'solve', options: workItems[currentWorkItem++] });\n            }\n        }\n    });\n};\n\nconst loadWords = url => fetch(url).then(response => response.text());\nconst fileReader = new FileReader();\nfileReader.addEventListener('load', async evt => await solve(evt.target.result));\n\nsolveButtonElem.addEventListener('click', async evt => {\n    evt.preventDefault();\n    solveButtonElem.disabled = true;\n    solveButtonElem.innerText = 'Loading...';\n\n    switch (wordListRadio.value) {\n        case 'custom': {\n            fileReader.readAsText(customWordFileElem.files[0]);\n            break;\n        }\n        case 'intersection': {\n            const setPromise = loadWords(wordlListElem.value);\n            const listPromise = loadWords(wordsAlphaListElem.value);\n            const set = await setPromise.then(str => new Set(str.split(crlfRegex)));\n            const list = await listPromise.then(str => str.split(crlfRegex));\n            await solve(list.filter(word => set.has(word)).join('\\n'));\n            break;\n        }\n        default: {\n            await solve(await loadWords(wordListRadio.value));\n            break;\n        }\n    }\n});\n\nconst encode = encodeURIComponent;\nif (location.hostname === 'waldin.net') {\n    const trackParams = Object.entries({\n        nc: Date.now(),\n        code: '840xigs5jBlPzxN77diWdugPDGjroC6y',\n        url: encode(location.href),\n        t: encode(document.title),\n        ref: encode(document.referrer),\n        w: screen.width,\n        h: screen.height,\n    });\n    fetch(`https://api.pirsch.io/hit?${trackParams.map(([k, v]) => `${k}=${v}`).join('&')}`);\n}\n"],
  "mappings": "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",
  "names": ["ios", "availableConcurrency", "numberFormatter", "numberFormat", "number", "crlfRegex", "solutionsElem", "solveFormElem", "outputFormElem", "workers", "_", "worker", "evt", "customWordFileElem", "solveButtonElem", "concurrencyElem", "wordListRadio", "wordCountElem", "fiveLetterWordCountElem", "normalizedWordCountElem", "solutionCountElem", "elapsedTimeElem", "workItemsElem", "workersWorkingElem", "customWordListElem", "value", "wordlListElem", "wordsAlphaListElem", "n", "option", "solve", "wordsString", "startTime", "allWords", "word", "fiveLetterWords", "normalizedWordMap", "normalizedWord", "entry", "words", "options", "a", "allChars", "i", "usedChars", "missingChars", "char", "solutions", "displaySolutions", "workItems", "workItem1", "workItem2", "recordSolution", "solution", "normalizedSolution", "step", "currentWorkItem", "completedWorkItems", "renderInterval", "resolve", "messageHandler", "msg", "loadWords", "url", "response", "fileReader", "setPromise", "listPromise", "set", "str", "list", "encode", "trackParams", "k", "v"]
}
