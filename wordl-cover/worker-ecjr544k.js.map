{
  "version": 3,
  "sources": ["../src/dancinglinks.js", "../src/worker.js"],
  "sourcesContent": ["/*\n    Implementation of Donald Knuth's DancingLinks technique for solving the exact cover problem.\n    See https://en.wikipedia.org/wiki/Dancing_Links\n*/\nclass Node {\n    constructor(value, left) {\n        this.value = value;\n        this.left = left ?? this;\n        this.right = this.up = this.down = this;\n    }\n\n    insertBelow(up) {\n        this.up = up;\n        this.down = up.down;\n        up.down.up = up.down = this;\n    }\n\n    removeVertically() {\n        this.up.down = this.down;\n        this.down.up = this.up;\n        this.column.rowCount--;\n    }\n\n    reinsertVertically() {\n        this.up.down = this.down.up = this;\n        this.column.rowCount++;\n    }\n\n    removeHorizontally() {\n        this.left.right = this.right;\n        this.right.left = this.left;\n    }\n\n    reinsertHorizontally() {\n        this.left.right = this.right.left = this;\n    }\n}\n\nclass Column extends Node {\n    constructor(value, left) {\n        super(value, left);\n        this.rowCount = 0;\n        this.column = this;\n    }\n}\n\nconst cover = node => {\n    const column = node.column;\n    column.removeHorizontally();\n    for (let row = column.down; row !== column; row = row.down) {\n        column.header.rowCount--;\n        for (let peer = row.right; peer !== row; peer = peer.right) {\n            peer.removeVertically();\n        }\n    }\n};\n\nconst uncover = node => {\n    const column = node.column;\n    for (let row = column.up; row !== column; row = row.up) {\n        for (let peer = row.left; peer !== row; peer = peer.left) {\n            peer.reinsertVertically();\n        }\n        column.header.rowCount++;\n    }\n    column.reinsertHorizontally();\n};\n\nconst selectColumn = columns => {\n    let minColumn;\n    for (let column = columns.right; column !== columns; column = column.right) {\n        if (column.rowCount === 0) {\n            return column;\n        }\n        if (!minColumn || column.rowCount < minColumn.rowCount) {\n            minColumn = column;\n        }\n    }\n    return minColumn;\n};\n\nexport function* solve(options, givenOptions = []) {\n    const items = [...new Set(Object.values(options).flat())];\n    const columns = new Node('columns');\n\n    // build \"horizontally\" connected column header nodes\n    columns.left = items.reduce((left, item) => (left.right = new Column(item, left)), columns);\n    columns.left.right = columns;\n\n    const columnsByItem = new Map();\n\n    for (let column = columns.right; column !== columns; column = column.right) {\n        columnsByItem.set(column.value, column);\n        column.header = columns;\n    }\n\n    columns.rowCount = 0;\n\n    const rowsByOption = new Map();\n    for (const [option, items] of Object.entries(options)) {\n        const rowHeader = new Node();\n\n        // build \"horizontally\" connected row of nodes\n        rowHeader.left = items.reduce((left, item) => (left.right = new Node(item, left)), rowHeader);\n        rowHeader.left.right = rowHeader;\n        for (let row = rowHeader.right; row !== rowHeader; row = row.right) {\n            const column = columnsByItem.get(row.value);\n            // insert each row node \"vertically\" into it's corresponding column\n            row.insertBelow(column.up);\n            row.column = column;\n            ++column.rowCount;\n            row.option = option;\n        }\n        rowsByOption.set(option, rowHeader.right);\n        rowHeader.removeHorizontally();\n        ++columns.rowCount;\n    }\n\n    const columnContains = (column, row) => {\n        for (let r = column.down; r !== column; r = r.down) {\n            if (r === row) {\n                return r;\n            }\n        }\n    };\n\n    const solution = [];\n    for (const option of givenOptions) {\n        const row = rowsByOption.get(option);\n        if (row && columnContains(row.column, row)) {\n            cover(row);\n            for (let peer = row.right; peer !== row; peer = peer.right) {\n                cover(peer);\n            }\n            solution.push(row.option);\n            rowsByOption.delete(option);\n        } else {\n            // given is impossible in this puzzle\n            return;\n        }\n    }\n\n    let lastYield;\n    function* search(depth) {\n        const column = selectColumn(columns);\n        if (!column) {\n            yield [...solution];\n            lastYield = Date.now();\n            return;\n        } else if (column.rowCount === 0) {\n            return;\n        }\n\n        if (Date.now() - lastYield > 500) {\n            yield;\n            lastYield = Date.now();\n        }\n\n        cover(column);\n        for (let row = column.down; row !== column; row = row.down) {\n            solution.push(row.option);\n            for (let peer = row.right; peer !== row; peer = peer.right) {\n                cover(peer);\n            }\n\n            yield* search(depth + 1);\n\n            for (let peer = row.left; peer !== row; peer = peer.left) {\n                uncover(peer);\n            }\n            solution.pop();\n        }\n        uncover(column);\n    }\n\n    yield* search(givenOptions.length);\n}\n", "import { solve } from './dancinglinks.js';\n\naddEventListener('message', ({ data: { type, options } }) => {\n    if (type === 'solve') {\n        for (const solution of solve(options)) {\n            if (solution) {\n                postMessage({ type: 'solution', solution });\n            }\n        }\n        postMessage({ type: 'completed' });\n    }\n});\n"],
  "mappings": "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",
  "names": ["Node", "value", "left", "up", "Column", "cover", "node", "column", "row", "peer", "uncover", "selectColumn", "columns", "minColumn", "solve", "options", "givenOptions", "items", "item", "columnsByItem", "rowsByOption", "option", "rowHeader", "columnContains", "r", "solution", "lastYield", "search", "depth", "type", "options", "solution", "solve"]
}
