{
  "version": 3,
  "sources": ["../src/dancinglinks.js", "../src/worker.js"],
  "sourcesContent": ["/*\n    Implementation of Donald Knuth's DancingLinks technique for solving the exact cover problem.\n    See https://en.wikipedia.org/wiki/Dancing_Links\n*/\nclass Node {\n    constructor(value, left) {\n        this.value = value;\n        this.left = left ?? this;\n        this.right = this.up = this.down = this;\n    }\n\n    insertBelow(up) {\n        this.up = up;\n        this.down = up.down;\n        up.down.up = up.down = this;\n    }\n\n    removeVertically() {\n        this.up.down = this.down;\n        this.down.up = this.up;\n        this.column.rowCount--;\n    }\n\n    reinsertVertically() {\n        this.up.down = this.down.up = this;\n        this.column.rowCount++;\n    }\n\n    removeHorizontally() {\n        this.left.right = this.right;\n        this.right.left = this.left;\n    }\n\n    reinsertHorizontally() {\n        this.left.right = this.right.left = this;\n    }\n\n    eachPeerDown(fn) {\n        for (let peer = this.down; peer !== this; peer = peer.down) {\n            fn(peer);\n        }\n    }\n\n    eachPeerRight(fn) {\n        for (let peer = this.right; peer !== this; peer = peer.right) {\n            fn(peer);\n        }\n    }\n}\n\nclass Column extends Node {\n    constructor(value, left) {\n        super(value, left);\n        this.rowCount = 0;\n        this.column = this;\n    }\n\n    removeHorizontally() {\n        super.removeHorizontally();\n        this.header.columnCount--;\n    }\n\n    reinsertHorizontally() {\n        super.reinsertHorizontally();\n        this.header.columnCount++;\n    }\n}\n\nconst cover = node => {\n    const column = node.column ?? node;\n    column.removeHorizontally();\n    for (let row = column.down; row !== column; row = row.down) {\n        column.header.rowCount--;\n        for (let peer = row.right; peer !== row; peer = peer.right) {\n            peer.removeVertically();\n        }\n    }\n};\n\nconst uncover = node => {\n    const column = node.column ?? node;\n    for (let row = column.up; row !== column; row = row.up) {\n        for (let peer = row.left; peer !== row; peer = peer.left) {\n            peer.reinsertVertically();\n        }\n        column.header.rowCount++;\n    }\n    column.reinsertHorizontally();\n};\n\nconst selectColumn = columns => {\n    let minColumn;\n    for (let column = columns.right; column !== columns; column = column.right) {\n        if (column.rowCount === 0) {\n            return column;\n        }\n        if (!minColumn || column.rowCount < minColumn.rowCount) {\n            minColumn = column;\n        }\n    }\n    return minColumn;\n};\n\nexport function* solve(options, givenOptions = []) {\n    const items = [...new Set(Object.values(options).flat())];\n    const columns = new Node('columns');\n\n    // build \"horizontally\" connected column header nodes\n    columns.left = items.reduce((left, item) => (left.right = new Column(item, left)), columns);\n    columns.left.right = columns;\n\n    const columnsByItem = new Map();\n\n    columns.eachPeerRight(column => {\n        columnsByItem.set(column.value, column);\n        column.header = columns;\n    });\n\n    columns.columnCount = items.length;\n    columns.rowCount = 0;\n\n    const rowsByOption = new Map();\n    for (const [option, items] of Object.entries(options)) {\n        const rowHeader = new Node();\n\n        // build \"horizontally\" connected row of nodes\n        rowHeader.left = items.reduce((left, item) => (left.right = new Node(item, left)), rowHeader);\n        rowHeader.left.right = rowHeader;\n        rowHeader.eachPeerRight(row => {\n            const column = columnsByItem.get(row.value);\n            // insert each row node \"vertically\" into it's corresponding column\n            row.insertBelow(column.up);\n            row.column = column;\n            ++column.rowCount;\n            row.option = option;\n        });\n        rowsByOption.set(option, rowHeader.right);\n        rowHeader.removeHorizontally();\n        ++columns.rowCount;\n    }\n\n    const columnContains = (column, row) => {\n        for (let r = column.down; r !== column; r = r.down) {\n            if (r === row) {\n                return r;\n            }\n        }\n    };\n\n    const solution = [];\n    for (const option of givenOptions) {\n        const row = rowsByOption.get(option);\n        if (row && columnContains(row.column, row)) {\n            cover(row);\n            row.eachPeerRight(cover);\n            solution.push(row.option);\n            rowsByOption.delete(option);\n        } else {\n            // given is impossible in this puzzle\n            return;\n        }\n    }\n\n    let lastYield;\n    function* search(depth) {\n        const column = selectColumn(columns);\n        if (!column) {\n            yield [...solution];\n            lastYield = Date.now();\n            return;\n        } else if (column.rowCount === 0) {\n            return;\n        }\n\n        if (Date.now() - lastYield > 500) {\n            yield;\n            lastYield = Date.now();\n        }\n\n        cover(column);\n        for (let row = column.down; row !== column; row = row.down) {\n            solution.push(row.option);\n            for (let peer = row.right; peer !== row; peer = peer.right) {\n                cover(peer);\n            }\n\n            yield* search(depth + 1);\n\n            for (let peer = row.left; peer !== row; peer = peer.left) {\n                uncover(peer);\n            }\n            solution.pop();\n        }\n        uncover(column);\n    }\n\n    yield* search(givenOptions.length);\n}\n", "import { solve } from './dancinglinks.js';\n\naddEventListener('message', msg => {\n    switch (msg.data.type) {\n        case 'solve': {\n            for (const solution of solve(msg.data.options, msg.data.givenOptions)) {\n                if (solution) {\n                    postMessage({ type: 'solution', solution });\n                }\n            }\n            postMessage({ type: 'completed' });\n        }\n    }\n});\n"],
  "mappings": "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",
  "names": ["Node", "value", "left", "up", "fn", "peer", "Column", "cover", "node", "column", "row", "uncover", "selectColumn", "columns", "minColumn", "solve", "options", "givenOptions", "items", "item", "columnsByItem", "rowsByOption", "option", "rowHeader", "columnContains", "r", "solution", "lastYield", "search", "depth", "msg", "solution", "solve"]
}
