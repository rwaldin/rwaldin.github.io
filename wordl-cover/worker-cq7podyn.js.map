{
  "version": 3,
  "sources": ["../src/dancinglinks.js", "../src/worker.js"],
  "sourcesContent": ["/*\n    Implementation of Donald Knuth's DancingLinks technique for solving the exact cover problem.\n    See https://en.wikipedia.org/wiki/Dancing_Links\n*/\nclass Node {\n    constructor(value, left = this) {\n        this.value = value;\n        this.left = left;\n        this.right = this.up = this.down = this;\n    }\n\n    insertBelow(up) {\n        this.up = up;\n        this.down = up.down;\n        up.down.up = up.down = this;\n        this.column = up.column;\n        ++this.column.rowCount;\n    }\n\n    removeVertically() {\n        this.up.down = this.down;\n        this.down.up = this.up;\n        --this.column.rowCount;\n    }\n\n    reinsertVertically() {\n        this.up.down = this.down.up = this;\n        ++this.column.rowCount;\n    }\n\n    removeHorizontally() {\n        this.left.right = this.right;\n        this.right.left = this.left;\n    }\n\n    reinsertHorizontally() {\n        this.left.right = this.right.left = this;\n    }\n}\n\nclass Column extends Node {\n    constructor(value, left) {\n        super(value, left);\n        this.rowCount = 0;\n        this.column = this;\n    }\n}\n\nconst cover = node => {\n    const column = node.column;\n    column.removeHorizontally();\n    for (let row = column.down; row !== column; row = row.down) {\n        --column.header.rowCount;\n        for (let peer = row.right; peer !== row; peer = peer.right) {\n            peer.removeVertically();\n        }\n    }\n};\n\nconst uncover = node => {\n    const column = node.column;\n    for (let row = column.up; row !== column; row = row.up) {\n        for (let peer = row.left; peer !== row; peer = peer.left) {\n            peer.reinsertVertically();\n        }\n        ++column.header.rowCount;\n    }\n    column.reinsertHorizontally();\n};\n\nconst selectColumn = columns => {\n    let minColumn;\n    for (let column = columns.right; column !== columns; column = column.right) {\n        if (column.rowCount === 0) {\n            return column;\n        }\n        if (!minColumn || column.rowCount < minColumn.rowCount) {\n            minColumn = column;\n        }\n    }\n    return minColumn;\n};\n\nexport function* solve(options, givenOptions = []) {\n    const items = [...new Set(Object.values(options).flat())];\n    const columns = new Column('columns');\n    const columnsByItem = new Map();\n    const maxYieldIntervalMs = 50;\n\n    const createColumn = (left, item) => {\n        const column = new Column(item, left);\n        columnsByItem.set(column.value, column);\n        column.header = columns;\n        return left.right = column;\n    };\n\n    // build horizontally connected column header nodes\n    columns.left = items.reduce(createColumn, columns);\n    columns.left.right = columns;\n\n    const rowsByOption = new Map();\n    for (const [option, items] of Object.entries(options)) {\n        const rowHeader = new Node();\n\n        const createRow = (left, item) => {\n            const row = new Node(item, left);\n            const column = columnsByItem.get(row.value);\n            // insert each row node vertically into it's corresponding column\n            row.insertBelow(column.up);\n            row.option = option;\n            return left.right = row;\n        };\n\n        // build horizontally connected row of nodes\n        rowHeader.left = items.reduce(createRow, rowHeader);\n        rowHeader.left.right = rowHeader;\n\n        rowsByOption.set(option, rowHeader.right);\n        rowHeader.removeHorizontally();\n        ++columns.rowCount;\n    }\n\n    const columnContains = (column, row) => {\n        for (let peer = column.down; peer !== column; peer = peer.down) {\n            if (peer === row) {\n                return true;\n            }\n        }\n    };\n\n    const solution = [];\n    for (const option of givenOptions) {\n        const row = rowsByOption.get(option);\n        if (row && columnContains(row.column, row)) {\n            cover(row);\n            for (let peer = row.right; peer !== row; peer = peer.right) {\n                cover(peer);\n            }\n            solution.push(row.option);\n            rowsByOption.delete(option);\n        } else {\n            // given option is impossible\n            return;\n        }\n    }\n\n    let lastYieldMs = Date.now();\n    \n    function* search() {\n        const now = Date.now();\n        const column = selectColumn(columns);\n\n        if (!column) {\n            // all requirements have been met, yield a solution\n            yield [...solution];\n            lastYieldMs = now;\n            return;\n        } \n        \n        if (column.rowCount === 0) {\n            // an unfulfilled requirement cannot be satisfied with remaining options ... dead end, backtrack\n            return;\n        }\n\n        if (now - lastYieldMs > maxYieldIntervalMs) {\n            // periodically relinquish control back to caller without a solution\n            yield;\n            lastYieldMs = now;\n        }\n\n        // try satisfying the requirement represented by column\n        cover(column);\n        for (let row = column.down; row !== column; row = row.down) {\n            solution.push(row.option);\n            \n            for (let peer = row.right; peer !== row; peer = peer.right) {\n                cover(peer);\n            }\n\n            yield* search();\n            \n            for (let peer = row.left; peer !== row; peer = peer.left) {\n                uncover(peer);\n            }\n            \n            solution.pop();\n        }\n        uncover(column);\n    }\n\n    yield* search();\n}\n", "import { solve } from './dancinglinks.js';\n\naddEventListener('message', msg => {\n    if (msg.data.type === 'solve') {\n        for (const solution of solve(msg.data.options)) {\n            if (solution) {\n                postMessage({ type: 'solution', solution });\n            }\n        }\n        postMessage({ type: 'completed' });\n    }\n});\n"],
  "mappings": "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",
  "names": ["Node", "value", "left", "up", "Column", "cover", "node", "column", "row", "peer", "uncover", "selectColumn", "columns", "minColumn", "solve", "options", "givenOptions", "items", "columnsByItem", "maxYieldIntervalMs", "createColumn", "item", "rowsByOption", "option", "rowHeader", "createRow", "columnContains", "solution", "lastYieldMs", "search", "now", "msg", "solution", "solve"]
}
