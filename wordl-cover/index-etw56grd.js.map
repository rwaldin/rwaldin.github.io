{
  "version": 3,
  "sources": ["../src/index.js"],
  "sourcesContent": ["const ios = /iPad|iPhone/.test(navigator.userAgent);\nconst availableConcurrency = 'hardwareConcurrency' in navigator ? navigator.hardwareConcurrency : ios ? 2 : 8;\nconst workers = Array.from({ length: availableConcurrency }, _ => new Worker('./worker.js'));\nconst numberFormatter = new Intl.NumberFormat();\nconst numberFormat = number => numberFormatter.format(number);\nconst loadWords = async url => fetch(url).then(res => res.text());\nconst crlfRegex = /\\r?\\n/;\n\nconst { solutionsElem, solveFormElem, outputFormElem } = window;\n\nconst {\n    wordCount: wordCountElem,\n    fiveLetterWordCount: fiveLetterWordCountElem,\n    normalizedWordCount: normalizedWordCountElem,\n    solutionCount: solutionCountElem,\n    elapsedTime: elapsedTimeElem,\n    workItems: workItemsElem,\n    workersWorking: workersWorkingElem,\n} = outputFormElem;\n\nconst {\n    customWordFile: customWordFileElem,\n    solveButton: solveButtonElem,\n    concurrency: concurrencyElem,\n    wordList: wordListElems,\n} = solveFormElem;\n\nconst customWordListElem = [...wordListElems].find(({ value }) => value === 'custom');\nconst wordlListElem = [...wordListElems].find(({ value }) => value.match(/wordl/));\nconst wordsAlphaListElem = [...wordListElems].find(({ value }) => value.match(/words_alpha/));\n\nfor (let n = 0; n < availableConcurrency; ++n) {\n    const option = document.createElement('option');\n    option.append(n + 1);\n    concurrencyElem.append(option);\n}\n\nconcurrencyElem.value = availableConcurrency;\ncustomWordFileElem.addEventListener('change', e => (wordListElems.value = 'custom'));\ncustomWordListElem.addEventListener('change', e => {\n    if (wordListElems.value === 'custom' && !customWordFileElem.value) {\n        customWordFileElem.click();\n    }\n});\n\nconst solve = wordsString => {\n    const startTime = Date.now();\n\n    solveButtonElem.innerText = 'Solving...';\n    solutionsElem.innerHTML = '';\n    solutionCountElem.innerText = 0;\n\n    const allWords = wordsString.split(crlfRegex).map(word => word.trim().toLowerCase());\n    wordCountElem.innerText = numberFormat(allWords.length);\n\n    const fiveLetterWords = allWords.filter(word => /^[a-z]{5}$/.test(word));\n    fiveLetterWordCountElem.innerText = numberFormat(fiveLetterWords.length);\n\n    // normalizedWords are fiveLetterWords with their letters rearranged so that they are sorted (WORDS becomes DORSW).\n    // Anagrams are removed from consideration by searching for normalizedWords instead of actual words since all anagrams\n    // map to the same normalizedWord.  Normalized words with any repeating characters /(.)\\1/ are also removed.\n    const normalizedWordMap = new Map();\n    for (const word of fiveLetterWords) {\n        const normalizedWord = [...word].sort().join('');\n        // ignore normalized words with repeating characters\n        if (!normalizedWord.match(/(.)\\1/)) {\n            const entry = normalizedWordMap.get(normalizedWord);\n            // combine anagrams for display later\n            normalizedWordMap.set(normalizedWord, entry ? `${entry}/${word}` : word);\n        }\n    }\n    normalizedWordCountElem.innerText = numberFormat(normalizedWordMap.size);\n\n    const a = 'a'.charCodeAt(0);\n\n    const words = [...normalizedWordMap.keys()];\n    const options = Object.fromEntries(words.map(word => [word, word.split('')]));\n\n    const allChars = new Set(Object.values(options).flat());\n    if (allChars.size !== 26) {\n        const missingChars = Array.from({ length: 26 }, (_, i) => String.fromCharCode(a + i)).filter(char => !allChars.includes(char));\n        solutionsElem.appendChild(document.createElement('li')).append(`Invalid word list. Missing letters: ${missingChars.join(', ')}`);\n        return;\n    }\n\n    const solutions = new Set();\n    const displaySolutions = [];\n\n    const workItems = Array.from({ length: 26 }, (_, i) => String.fromCharCode(a + i)).map(char =>\n        Object.fromEntries(Object.entries(options).filter(([word]) => !word.includes(char)))\n    );\n    // sort work in descending order of options to reduce the time long-pole dangling workers require\n    // .sort((workItem1, workItem2) => Object.keys(workItem2).length - Object.keys(workItem1).length);\n\n    const recordSolution = solution => {\n        // ignore solutions that contain the same normalized words as an already recorded solution, but in a different order\n        const normalizedSolution = solution.sort().join(',');\n        if (!solutions.has(normalizedSolution)) {\n            solutions.add(normalizedSolution);\n            solutionCountElem.innerText = numberFormat(solutions.size);\n            displaySolutions.push(\n                normalizedSolution\n                    .split(',')\n                    .map(step => normalizedWordMap.get(step))\n                    .sort()\n                    .join(', ')\n            );\n        }\n    };\n\n    const render = _ => {\n        // append list elements for newly arrived solutions since last render\n        for (let i = solutionsElem.children.length; i < displaySolutions.length; ++i) {\n            solutionsElem.appendChild(document.createElement('li')).append(displaySolutions[i]);\n        }\n        elapsedTimeElem.innerText = `${numberFormat((Date.now() - startTime) / 1000)} seconds`;\n        solutionsElem.scrollTop = solutionsElem.scrollHeight;\n    };\n\n    const renderInterval = setInterval(_ => requestAnimationFrame(render), 60);\n\n    let currentWorkItem = 0;\n    let completedWorkItems = 0;\n\n    const concurrency = concurrencyElem.value;\n\n    return new Promise((resolve, reject) => {\n        for (const [n, worker] of workers.entries()) {\n            if (n >= concurrency) {\n                break;\n            }\n            workersWorkingElem.value = n + 1;\n            const messageHandler = msg => {\n                switch (msg.data.type) {\n                    case 'solution': {\n                        recordSolution(msg.data.solution);\n                        break;\n                    }\n\n                    case 'completed': {\n                        if (++completedWorkItems < workItems.length) {\n                            if (currentWorkItem < workItems.length) {\n                                worker.postMessage({ type: 'solve', options: workItems[currentWorkItem++] });\n                            } else {\n                                workersWorkingElem.value -= 1;\n                                worker.removeEventListener('message', messageHandler);\n                            }\n                        } else if (completedWorkItems === workItems.length) {\n                            const elapsedSeconds = (Date.now() - startTime) / 1000;\n                            worker.removeEventListener('message', messageHandler);\n                            workersWorkingElem.value -= 1;\n                            elapsedTimeElem.innerText = `${numberFormat(elapsedSeconds)} seconds`;\n                            solveButtonElem.disabled = false;\n                            solveButtonElem.innerHTML = 'Solve';\n                            clearInterval(renderInterval);\n                            resolve();\n                        }\n                        workItemsElem.value = workItems.length - completedWorkItems;\n                        break;\n                    }\n                }\n            };\n\n            if (currentWorkItem < workItems.length) {\n                worker.addEventListener('message', messageHandler);\n                worker.postMessage({ type: 'solve', options: workItems[currentWorkItem++] });\n            }\n        }\n    });\n};\n\nsolveButtonElem.addEventListener('click', async e => {\n    e.preventDefault();\n    solveButtonElem.disabled = true;\n    solveButtonElem.innerText = 'Loading...';\n    const formData = Object.fromEntries([...new FormData(solveFormElem)]);\n    if (formData.wordList === 'custom') {\n        var reader = new FileReader();\n        reader.onload = e => solve(event.target.result);\n        reader.readAsText(formData.customWordFile);\n    } else if (formData.wordList === 'intersection') {\n        loadWords(wordlListElem.value).then(str1 => {\n            const list1 = str1.split(crlfRegex);\n            loadWords(wordsAlphaListElem.value).then(str2 => {\n                const list2 = new Set(str2.split(crlfRegex));\n                solve(list1.filter(word => list2.has(word)).join('\\n'));\n            });\n        });\n    } else {\n        loadWords(formData.wordList).then(solve);\n    }\n});\n"],
  "mappings": "MAAA,IAAMA,EAAM,cAAc,KAAK,UAAU,SAAS,EAC5CC,EAAuB,wBAAyB,UAAY,UAAU,oBAAsBD,EAAM,EAAI,EACtGE,EAAU,MAAM,KAAK,CAAE,OAAQD,CAAqB,EAAGE,GAAK,IAAI,OAAO,aAAa,CAAC,EACrFC,EAAkB,IAAI,KAAK,aAC3BC,EAAeC,GAAUF,EAAgB,OAAOE,CAAM,EACtDC,EAAY,MAAMC,GAAO,MAAMA,CAAG,EAAE,KAAKC,GAAOA,EAAI,KAAK,CAAC,EAC1DC,EAAY,QAEZ,CAAE,cAAAC,EAAe,cAAAC,EAAe,eAAAC,CAAe,EAAI,OAEnD,CACF,UAAWC,EACX,oBAAqBC,EACrB,oBAAqBC,EACrB,cAAeC,EACf,YAAaC,EACb,UAAWC,EACX,eAAgBC,CACpB,EAAIP,EAEE,CACF,eAAgBQ,EAChB,YAAaC,EACb,YAAaC,EACb,SAAUC,CACd,EAAIZ,EAEEa,EAAqB,CAAC,GAAGD,CAAa,EAAE,KAAK,CAAC,CAAE,MAAAE,CAAM,IAAMA,IAAU,QAAQ,EAC9EC,EAAgB,CAAC,GAAGH,CAAa,EAAE,KAAK,CAAC,CAAE,MAAAE,CAAM,IAAMA,EAAM,MAAM,OAAO,CAAC,EAC3EE,EAAqB,CAAC,GAAGJ,CAAa,EAAE,KAAK,CAAC,CAAE,MAAAE,CAAM,IAAMA,EAAM,MAAM,aAAa,CAAC,EAE5F,QAASG,EAAI,EAAGA,EAAI5B,EAAsB,EAAE4B,EAAG,CAC3C,IAAMC,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,OAAOD,EAAI,CAAC,EACnBN,EAAgB,OAAOO,CAAM,CACjC,CAEAP,EAAgB,MAAQtB,EACxBoB,EAAmB,iBAAiB,SAAUU,GAAMP,EAAc,MAAQ,QAAS,EACnFC,EAAmB,iBAAiB,SAAUM,GAAK,CAC3CP,EAAc,QAAU,UAAY,CAACH,EAAmB,OACxDA,EAAmB,MAAM,CAEjC,CAAC,EAED,IAAMW,EAAQC,GAAe,CACzB,IAAMC,EAAY,KAAK,IAAI,EAE3BZ,EAAgB,UAAY,aAC5BX,EAAc,UAAY,GAC1BM,EAAkB,UAAY,EAE9B,IAAMkB,EAAWF,EAAY,MAAMvB,CAAS,EAAE,IAAI0B,GAAQA,EAAK,KAAK,EAAE,YAAY,CAAC,EACnFtB,EAAc,UAAYT,EAAa8B,EAAS,MAAM,EAEtD,IAAME,EAAkBF,EAAS,OAAOC,GAAQ,aAAa,KAAKA,CAAI,CAAC,EACvErB,EAAwB,UAAYV,EAAagC,EAAgB,MAAM,EAKvE,IAAMC,EAAoB,IAAI,IAC9B,QAAWF,KAAQC,EAAiB,CAChC,IAAME,EAAiB,CAAC,GAAGH,CAAI,EAAE,KAAK,EAAE,KAAK,EAAE,EAE/C,GAAI,CAACG,EAAe,MAAM,OAAO,EAAG,CAChC,IAAMC,EAAQF,EAAkB,IAAIC,CAAc,EAElDD,EAAkB,IAAIC,EAAgBC,EAAQ,GAAGA,KAASJ,IAASA,CAAI,CAC3E,CACJ,CACApB,EAAwB,UAAYX,EAAaiC,EAAkB,IAAI,EAEvE,IAAMG,EAAI,IAAI,WAAW,CAAC,EAEpBC,EAAQ,CAAC,GAAGJ,EAAkB,KAAK,CAAC,EACpCK,EAAU,OAAO,YAAYD,EAAM,IAAIN,GAAQ,CAACA,EAAMA,EAAK,MAAM,EAAE,CAAC,CAAC,CAAC,EAEtEQ,EAAW,IAAI,IAAI,OAAO,OAAOD,CAAO,EAAE,KAAK,CAAC,EACtD,GAAIC,EAAS,OAAS,GAAI,CACtB,IAAMC,EAAe,MAAM,KAAK,CAAE,OAAQ,EAAG,EAAG,CAAC1C,EAAG2C,IAAM,OAAO,aAAaL,EAAIK,CAAC,CAAC,EAAE,OAAOC,GAAQ,CAACH,EAAS,SAASG,CAAI,CAAC,EAC7HpC,EAAc,YAAY,SAAS,cAAc,IAAI,CAAC,EAAE,OAAO,uCAAuCkC,EAAa,KAAK,IAAI,GAAG,EAC/H,MACJ,CAEA,IAAMG,EAAY,IAAI,IAChBC,EAAmB,CAAC,EAEpBC,EAAY,MAAM,KAAK,CAAE,OAAQ,EAAG,EAAG,CAAC/C,EAAG2C,IAAM,OAAO,aAAaL,EAAIK,CAAC,CAAC,EAAE,IAAIC,GACnF,OAAO,YAAY,OAAO,QAAQJ,CAAO,EAAE,OAAO,CAAC,CAACP,CAAI,IAAM,CAACA,EAAK,SAASW,CAAI,CAAC,CAAC,CACvF,EAIMI,EAAiBC,GAAY,CAE/B,IAAMC,EAAqBD,EAAS,KAAK,EAAE,KAAK,GAAG,EAC9CJ,EAAU,IAAIK,CAAkB,IACjCL,EAAU,IAAIK,CAAkB,EAChCpC,EAAkB,UAAYZ,EAAa2C,EAAU,IAAI,EACzDC,EAAiB,KACbI,EACK,MAAM,GAAG,EACT,IAAIC,GAAQhB,EAAkB,IAAIgB,CAAI,CAAC,EACvC,KAAK,EACL,KAAK,IAAI,CAClB,EAER,EAEMC,EAASpD,GAAK,CAEhB,QAAS2C,EAAInC,EAAc,SAAS,OAAQmC,EAAIG,EAAiB,OAAQ,EAAEH,EACvEnC,EAAc,YAAY,SAAS,cAAc,IAAI,CAAC,EAAE,OAAOsC,EAAiBH,EAAE,EAEtF5B,EAAgB,UAAY,GAAGb,GAAc,KAAK,IAAI,EAAI6B,GAAa,GAAI,YAC3EvB,EAAc,UAAYA,EAAc,YAC5C,EAEM6C,EAAiB,YAAYrD,GAAK,sBAAsBoD,CAAM,EAAG,EAAE,EAErEE,EAAkB,EAClBC,EAAqB,EAEnBC,EAAcpC,EAAgB,MAEpC,OAAO,IAAI,QAAQ,CAACqC,EAASC,IAAW,CACpC,OAAW,CAAChC,EAAGiC,CAAM,IAAK5D,EAAQ,QAAQ,EAAG,CACzC,GAAI2B,GAAK8B,EACL,MAEJvC,EAAmB,MAAQS,EAAI,EAC/B,IAAMkC,EAAiBC,GAAO,CAC1B,OAAQA,EAAI,KAAK,UACR,WAAY,CACbb,EAAea,EAAI,KAAK,QAAQ,EAChC,KACJ,KAEK,YAAa,CACd,GAAI,EAAEN,EAAqBR,EAAU,OAC7BO,EAAkBP,EAAU,OAC5BY,EAAO,YAAY,CAAE,KAAM,QAAS,QAASZ,EAAUO,IAAmB,CAAC,GAE3ErC,EAAmB,OAAS,EAC5B0C,EAAO,oBAAoB,UAAWC,CAAc,WAEjDL,IAAuBR,EAAU,OAAQ,CAChD,IAAMe,GAAkB,KAAK,IAAI,EAAI/B,GAAa,IAClD4B,EAAO,oBAAoB,UAAWC,CAAc,EACpD3C,EAAmB,OAAS,EAC5BF,EAAgB,UAAY,GAAGb,EAAa4D,CAAc,YAC1D3C,EAAgB,SAAW,GAC3BA,EAAgB,UAAY,QAC5B,cAAckC,CAAc,EAC5BI,EAAQ,CACZ,CACAzC,EAAc,MAAQ+B,EAAU,OAASQ,EACzC,KACJ,EAER,EAEID,EAAkBP,EAAU,SAC5BY,EAAO,iBAAiB,UAAWC,CAAc,EACjDD,EAAO,YAAY,CAAE,KAAM,QAAS,QAASZ,EAAUO,IAAmB,CAAC,EAEnF,CACJ,CAAC,CACL,EAEAnC,EAAgB,iBAAiB,QAAS,MAAMS,GAAK,CACjDA,EAAE,eAAe,EACjBT,EAAgB,SAAW,GAC3BA,EAAgB,UAAY,aAC5B,IAAM4C,EAAW,OAAO,YAAY,CAAC,GAAG,IAAI,SAAStD,CAAa,CAAC,CAAC,EACpE,GAAIsD,EAAS,WAAa,SAAU,CAChC,IAAIC,EAAS,IAAI,WACjBA,EAAO,OAASpC,GAAKC,EAAM,MAAM,OAAO,MAAM,EAC9CmC,EAAO,WAAWD,EAAS,cAAc,CAC7C,MAAWA,EAAS,WAAa,eAC7B3D,EAAUoB,EAAc,KAAK,EAAE,KAAKyC,GAAQ,CACxC,IAAMC,EAAQD,EAAK,MAAM1D,CAAS,EAClCH,EAAUqB,EAAmB,KAAK,EAAE,KAAK0C,GAAQ,CAC7C,IAAMC,EAAQ,IAAI,IAAID,EAAK,MAAM5D,CAAS,CAAC,EAC3CsB,EAAMqC,EAAM,OAAOjC,GAAQmC,EAAM,IAAInC,CAAI,CAAC,EAAE,KAAK;AAAA,CAAI,CAAC,CAC1D,CAAC,CACL,CAAC,EAED7B,EAAU2D,EAAS,QAAQ,EAAE,KAAKlC,CAAK,CAE/C,CAAC",
  "names": ["ios", "availableConcurrency", "workers", "_", "numberFormatter", "numberFormat", "number", "loadWords", "url", "res", "crlfRegex", "solutionsElem", "solveFormElem", "outputFormElem", "wordCountElem", "fiveLetterWordCountElem", "normalizedWordCountElem", "solutionCountElem", "elapsedTimeElem", "workItemsElem", "workersWorkingElem", "customWordFileElem", "solveButtonElem", "concurrencyElem", "wordListElems", "customWordListElem", "value", "wordlListElem", "wordsAlphaListElem", "n", "option", "e", "solve", "wordsString", "startTime", "allWords", "word", "fiveLetterWords", "normalizedWordMap", "normalizedWord", "entry", "a", "words", "options", "allChars", "missingChars", "i", "char", "solutions", "displaySolutions", "workItems", "recordSolution", "solution", "normalizedSolution", "step", "render", "renderInterval", "currentWorkItem", "completedWorkItems", "concurrency", "resolve", "reject", "worker", "messageHandler", "msg", "elapsedSeconds", "formData", "reader", "str1", "list1", "str2", "list2"]
}
