var worker=function(t){"use strict";const e=(t,e=(t=>t))=>Array.from({length:t},((t,s)=>e(s))),s=t=>t.reduce(((t,e)=>t+Number(e)),0),i=(t,...e)=>e.length?[...t].flatMap((t=>i(...e).map((e=>[t,e])))):[...t],n=t=>({on:()=>n(t),otherwise:()=>t}),o=t=>({on:(e,s)=>e(t)?n(s(t)):o(t),otherwise:e=>e(t)}),r=Math.PI,l=r/2,a=2*r,c={SOUTH:l,NORTH:-l,WEST:r,EAST:0,NORTHWEST:1.5*-l,NORTHEAST:.5*-l,SOUTHWEST:1.5*l,SOUTHEAST:.5*l},u={[c.NORTH]:1,[c.SOUTH]:1,[c.WEST]:1,[c.EAST]:1,[c.NORTHWEST]:Math.SQRT2,[c.NORTHEAST]:Math.SQRT2,[c.SOUTHWEST]:Math.SQRT2,[c.SOUTHEAST]:Math.SQRT2},h=(t,e)=>Math.sqrt(t**2+e**2),p=t=>t>r?p(t-a):t<=-r?p(t+a):t,f=(t,e,s)=>Object.entries(t).reduce(((s,[i,n])=>e(s,n,i,t)),s),d=(t,e)=>f(t,((t,s,i,n)=>(t.push(e(s,i,n)),t)),[]),m=(t,e,s)=>e*t+~~s,g=(t,e)=>({row:~~(e/t),col:e%t}),$=(t,e)=>Object.values(c).reduce(((s,i)=>(s[i]=w(t,e,i),s)),{}),v=(t,e)=>Object.entries(u).reduce(((s,[i,n])=>(1===n&&(s[i]=w(t,e,i)),s)),{}),w=(t,e,s)=>{const{row:i,col:n}=g(t,e),o=(r=[n,i],l=u[s],a=s,[r[0]+l*Math.cos(a),r[1]+l*Math.sin(a)]).map((t=>Math.round(t)));var r,l,a;if(o[0]>=0&&o[0]<t&&o[1]>=0&&o[1]<t)return m(t,o[1],o[0])},y={DIAGONAL_POSITIVE:c.SOUTHEAST,DIAGONAL_NEGATIVE:c.SOUTHWEST,COLUMN:c.SOUTH,ROW:c.EAST},b=[[c.NORTH],[c.WEST],[c.SOUTH],[c.EAST]],O=[[c.NORTH,c.NORTHWEST,c.WEST],[c.WEST,c.SOUTHWEST,c.SOUTH],[c.SOUTH,c.SOUTHEAST,c.EAST],[c.EAST,c.NORTHEAST,c.NORTH]],E=[Object.values(c)],T="LINE_DRAW",S="BOX_DRAW",_={CENTER_SIZE:"CENTER_SIZE",CORNER_SIZE:"CORNER_SIZE",PATH:"PATH",POINT:"POINT"},x=(t,e,i)=>{switch(t){case b:case E:case O:return((t,e,{positions:[i],point:n})=>{const o=[];for(const s of e){const e=[i];for(const n of s){const s=w(t,i,n);void 0!==s&&e.push(s)}e.length===s.length+1&&o.push(e)}return o.length>1&&o.sort(((e,i)=>s(e.map((e=>{const{row:s,col:i}=g(t,e),[o,r]=[i+.5-n.x,s+.5-n.y];return h(o,r)})))-s(i.map((e=>{const{row:s,col:i}=g(t,e),[o,r]=[i+.5-n.x,s+.5-n.y];return h(o,r)}))))),o[0]})(e,t,i);case y.DIAGONAL_POSITIVE:case y.DIAGONAL_NEGATIVE:case y.COLUMN:case y.ROW:return((t,e,{positions:[s]})=>[s,...[e,p(e+r)].flatMap((e=>{const i=[];let n=s;for(;void 0!==(n=w(t,n,e));)i.push(n);return i}))].sort(((t,e)=>t-e)))(e,t,i);case T:return j(e,i);case S:return C(e,i);case _.CORNER_SIZE:case _.CENTER_SIZE:case _.CORNERS:return[0];default:return[i.positions[0]]}},C=(t,{positions:[e,s]})=>{const i=[];if(null!=s){const{row:n,col:o}=g(t,s),{row:r,col:l}=g(t,e);for(let e=Math.min(n,r);e<=Math.max(n,r);++e)for(let s=Math.min(o,l);s<=Math.max(o,l);++s)i.push(m(t,e,s))}return i},j=(t,{positions:[e,s]})=>{const i=[];if(null==s)return[e];{let{col:n,row:o}=g(t,s),{col:r,row:l}=g(t,e);const a=Math.abs(r-n),c=n<r?1:-1,u=-Math.abs(l-o),h=o<l?1:-1;let p=a+u;for(;i.push(m(t,o,n)),n!==r||o!==l;){const t=2*p;t>=u&&(p+=u,n+=c),t<=a&&(p+=a,o+=h)}}return i},I=/r(?<row>\d)c(?<col>\d)|(?<letter>[a-j])(?<num>[1-9])|(?<pos>\d\d?)/i,z=(t,e)=>e.split(",").flatMap((e=>{const s=e.split(/[:;-]/);if(s.length>1){const[i,n]=z(t,s.join(","));return e.includes("-")?j(t,{positions:[n,i]}):C(t,{positions:[n,i]})}return((t,e=9)=>o(t.match(I)?.groups??{}).on((({row:t,col:e})=>t&&e),(({row:t,col:s})=>(t-1)*e+(s-1))).on((({letter:t,num:e})=>t&&e),(({letter:t,num:s})=>"ABCDEFGHJKLMNOPQ".indexOf(t.toUpperCase())*e+(s-1))).on((({pos:t})=>t),(({pos:t})=>t)).otherwise((t=>{})))(e,t)})),P=t=>16843009*((t=(858993459&(t-=t>>>1&1431655765))+(t>>>2&858993459))+(t>>>4)&252645135)>>>24,A=(t,s)=>{const i=e(t.length,(t=>[]));for(const[e,n]of t.entries())i[e]=s[n].filter((e=>t.includes(e))).map((e=>t.indexOf(e)));const n=[];for(let e=3;e<2**t.length;++e)if(!(P(e)<2)){for(let s=0;s<t.length;++s)e&1<<s&&(n[e]=e in n?n[e].filter((t=>t===s||i[s].includes(t))):[s,...i[s]]);n[e]&&n[e].length>P(e)&&(n[e]=[])}const o=0===n.length?[]:n.reduce(((t,e)=>e.length>t.length?e:t)).map((e=>t[e]));return 0===o.length?[t[0]]:o},M=(t,e)=>t.filter((t=>e.includes(t))),N="SINGLE_CHAIN_COLORED",R="SINGLE_CHAIN_UNCOLORED",U="FISH_WINGS",k=e(9),D=e(512,(t=>s(k.map((e=>t&1<<e?1:0))))),L=t=>{const e=[];for(let s=0;s<9;++s)t&1<<s&&e.push(s);return e},H=(t,s,i,n,o,r,l=(t=>!0))=>{const a=[],c=Object.keys(n).sort(),u=r.filter((t=>1===t.n)).reduce(((t,e)=>(t[e.values[0]-1].push(e),t)),e(9,(t=>[]))),h=e(2**t.size,(t=>{return s=t,e(10).reduce(((t,e)=>t+(s&1<<e?e:"")),"");var s})).sort(((t,e)=>t.length-e.length)).filter((t=>t.length>0&&t.length<8)),p=e(t.size**2,(t=>({}))),f=Object.fromEntries(c.map((t=>[t,k.map((t=>k.map((t=>0))))])));for(const t of c)for(const[e,o]of n[t].entries())for(const[n,r]of o.entries()){if(s[r])continue;p[r][t]=e;const o=i[r];for(const s of o)f[t][e][s-1]|=1<<n}const d=e(9,(t=>[])),m=h.reduce(((t,e)=>(t[e.length]=t[e.length]??[],t[e.length].push(e),t)),[]);for(const t of m)if(t)for(const e of c)for(const r of t){const t=k.map((t=>[]));for(const s of[...r])for(const i of k){D[f[e][s][i]]&&t[i].push(s)}for(const h of k)if(t[h].length&&t[h].length===r.length){const m=[];for(const t of[...r]){const s=n[e][t],i=L(f[e][t][h]);s.forEach(((t,e)=>{i.includes(e)&&m.push(t)}))}if(u[h].some((t=>m.some((e=>e===t.positions[0]))))||d[h].some((t=>t.every((t=>m.includes(t))))))continue;let g=!1;for(const o of c.filter((t=>t!==e))){const c=new Set;let u=!0;for(const t of m)o in p[t]?c.add(p[t][o]):u=!1;if(u&&c.size>0&&c.size<=r.length){const u=n[o].filter(((t,e)=>c.has(e))).flatMap((t=>t.filter((t=>!m.includes(t)&&i[t].includes(h+1)&&0===s[t]))));if(u.length&&m.length>1){g=!0;const s=t[h].map((t=>[e,~~t])),i=[...c].map((t=>[o,~~t])),n={type:U,n:r.length,positions:m,impactedPositions:u,units:s,impactedUnits:i,values:[h+1]};if(a.push(n),d[h].push(m),!l(n))return a}}}if(!g&&1===r.length){let s=[];for(const[t,e]of o.entries())i[t].includes(h+1)&&!m.includes(t)&&m.every((t=>e.includes(t)))&&s.push(t);if(s.length){const i=t[h].map((t=>[e,~~t])),n={type:U,n:r.length,positions:m,impactedPositions:s,units:i,values:[h+1]};if(a.push(n),d[h].push(m),!l(n))return a}}}}return a},F="NAKED_TUPLE",B="HIDDEN_TUPLE",q=(t,i,n,o,r,l)=>{const a=[],c=[],u=e(9),h=t=>s([...t].map((t=>1<<t-1))),p=t=>u.reduce(((e,s)=>e+(t&1<<s?s+1:"")),""),f=e(511,(t=>s(e(10,(e=>t&1<<e?1:0))))),m=t=>(c.push(t),l(t)),g=t=>{const s=[],r=n.map(h),l=e(512,(t=>{return e=t,u.reduce(((t,s)=>t+(e&1<<s?s:"")),"");var e})).sort(((t,e)=>t.length-e.length)).filter((t=>t.length>1&&t.length<5));for(const e of l){const l=Object.fromEntries(d(o,((t,e)=>[e,u.map((t=>u.map((t=>!1))))])));for(const[c,u]of Object.entries(o))t:for(const[o,h]of u.entries()){const u=e.length;let d=0,m=0,g=9;for(const t of e){const e=h[t];if(1===n[e].length||a.includes(e)||l[c][o][t])continue t}for(const[t,s]of h.entries()){const i=e.includes(t);1===n[s].length&&--g,i?d|=r[s]:m|=r[s]}if(f[d]===u&&u<g){const r=[...p(d)],a=[...e].map((t=>h[t])),f=h.filter((t=>!a.includes(t)&&r.some((e=>n[t].includes(e)))&&0===i[t])),m=s.find((t=>t.values.every((t=>r.includes(t)))&&t.positions.every((t=>a.includes(t)))));if(m){m.n===u&&m.type===F&&(m.units=[...m.units,[c,o]].reduce(((t,[e,s],i,n)=>(t[`${e} ${s}`]=[e,s],i===n.length-1?Object.values(t):t)),{}));continue}if(0===f.length)continue;const g={type:F,n:u,positions:a,impactedPositions:f,units:[[c,o]],values:r};if(s.push(g),!t(g))return s;for(const t of e)l[c][o][t]=!0;continue}const $=d&~m;let v=!0;for(const t of e)v=v&&$&r[h[t]];const w=[...p($)],y=[...e].map((t=>h[t])).sort(),b=h.filter((t=>!y.includes(t)&&w.some((e=>n[t].includes(e)))&&0===i[t]));if(v&&w.length===u&&u<g){const i=s.find((t=>t.values.every((t=>w.includes(t)))&&t.positions.every((t=>y.includes(t)))));if(i){i.n===u&&i.type===B&&(i.units=[...i.units,[c,o]].reduce(((t,[e,s],i,n)=>(t[`${e} ${s}`]=[e,s],i===n.length-1?Object.values(t):t)),{}));continue}const n={type:B,n:u,positions:y,impactedPositions:b,units:[[c,o]],values:w};if(s.push(n),!t(n))return s;for(const t of e)l[c][o][t]=!0}}}return s};return 0===(s=>{const l=[],c=e(t.size**2,(t=>[]));for(const[t,e]of Object.entries(o))for(const[s,i]of e.entries())for(const e of i)c[e].push({unitType:t,unitIndex:s,unit:i});for(const[t,e]of n.entries())if(0===i[t])if(1!==e.length)for(const{unitType:o,unit:u,unitIndex:h}of c[t]){const c=[...e].find((e=>u.every((s=>s===t||!n[s].includes(e))))),p=[...new Set(r[t].filter((t=>0===i[t]&&n[t].includes(c))))],f=l.find((e=>e.positions[0]===t));if(f)f.type===B&&(f.units=[...f.units,[o,h]].reduce(((t,[e,s],i,n)=>(t[`${e} ${s}`]=[e,s],i===n.length-1?Object.values(t):t)),{}));else if(c){const e={type:B,n:1,positions:[t],impactedPositions:p,units:[[o,h]],values:[c]};if(l.push(e),!s(e))return l;a.push(t)}}else{const o=[...new Set(r[t].filter((t=>0===i[t]&&n[t].includes(e))))],u=l.find((e=>e.positions[0]===t));if(u){u.type===F&&(u.units=[...u.units,[unitType,unitIndex]].reduce(((t,[e,s],i,n)=>(t[`${e} ${s}`]=[e,s],i===n.length-1?Object.values(t):t)),{}));continue}const h={type:F,n:1,positions:[t],impactedPositions:o,units:c[t].map((({unitType:t,unitIndex:e})=>[t,e])),values:[e]};if(l.push(h),!s(h))return l;a.push(t)}return l})((t=>(a.push(t.positions[0]),c.push(t),l(t)))).length&&g(m),c};class W{constructor(t,e){this.value=t,this.left=e??this,this.right=this.up=this.down=this}insertBelow(t){this.up=t,this.down=t.down,t.down.up=t.down=this}removeVertically(){this.up.down=this.down,this.down.up=this.up,this.column.rowCount--,this.column.rowWeight-=this.weight}reinsertVertically(){this.up.down=this.down.up=this,this.column.rowWeight+=this.weight,this.column.rowCount++}removeHorizontally(){this.left.right=this.right,this.right.left=this.left}reinsertHorizontally(){this.left.right=this.right.left=this}eachPeerDown(t){for(let e=this.down;e!==this;e=e.down)t(e)}eachPeerLeft(t){for(let e=this.left;e!==this;e=e.left)t(e)}eachPeerRight(t){for(let e=this.right;e!==this;e=e.right)t(e)}mapPeersRight(t){const e=[];for(let s=this.right;s!==this;s=s.right)e.push(t(s,e.length,this));return e}}class G extends W{constructor(t,e){super(t?.replace(/:multiple\(\d+\)$/,""),e),this.rowCount=0,this.rowWeight=0,this.matchCount=~~t?.replace(/^.*:multiple\((\d+)\)$/,"$1")||1}removeHorizontally(){super.removeHorizontally(),this.header.columnCount--}reinsertHorizontally(){super.reinsertHorizontally(),this.header.columnCount++}}const V=t=>{const e=t.column??t;if(0==--e.matchCount){e.removeHorizontally();for(let t=e.down;t!==e;t=t.down){e.header.rowCount--;for(let e=t.right;e!==t;e=e.right)e.removeVertically()}}},Z=t=>{const e=t.column??t;if(0==e.matchCount++){for(let t=e.up;t!==e;t=t.up){for(let e=t.left;e!==t;e=e.left)e.reinsertVertically();e.header.rowCount++}e.reinsertHorizontally()}};function*K(t,n,o={add:t=>!0,remove:t=>!0},r){let l=0;const a=Object.fromEntries(i("ABCDEFGHJ",e(9,(t=>t+1))).map((t=>[t.join(""),0]))),c=[...new Set(Object.values(t).flat())],u=new W("primaryColumns"),h=new W("secondaryColumns"),[p,f]=c.reduce((([t,e],s)=>(s.startsWith("optional:")||s.match(/:multiple\(\d+\)$/)?e.push(s.replace(/^optional:/,"")):t.push(s),[t,e])),[[],[]]);if(r){const t=((t=Date.now())=>{const e=2147483647;return(t%=e)<=0&&(t+=e),s=>((t=16807*t%e)-1)/e})(r??Date.now());p.sort((e=>~~(10*t()-5)))}u.left=p.reduce(((t,e)=>t.right=new G(e,t)),u),u.left.right=u,h.left=f.reduce(((t,e)=>t.right=new G(e,t)),h),h.left.right=h;const d=new Map;u.eachPeerRight((t=>{d.set(t.value,t),t.header=u})),h.eachPeerRight((t=>{d.set(t.value,t),t.header=h})),u.columnCount=p.length,h.columnCount=f.length,u.rowCount=0,h.rowCount=0;const m=new Map;for(const[e,i]of Object.entries(t)){const t=new W;t.left=i.reduce(((t,e)=>t.right=new W(e.replace(/^optional:|:multiple\(\d+\)$/g,""),t)),t),t.left.right=t,t.eachPeerRight((t=>{const s=d.get(t.value);t.insertBelow(s.up),t.column=s,++s.rowCount,t.item=t.value,t.value=e;const i=[...e];t.step=[i[0],i[1],i[3]]}));const n=s(t.mapPeersRight((t=>1/t.column.matchCount**2)));t.eachPeerRight((t=>{t.weight=n,t.column.rowWeight+=t.weight})),m.set(e,t.right),t.removeHorizontally(),u.rowCount++,h.rowCount++}const g=(t,e)=>{let s=!1;return t.eachPeerDown((t=>s=s||t===e)),s},$=[];for(const t of n){const e=m.get(t);if(!(e&&g(e.column,e)&&o.add([e.value[0],e.value[1],e.value[3]])))return;V(e),e.eachPeerRight(V),$.push(e.step),m.delete(t)}let v=0;yield*function*t(e){v=Math.max(e,v);const s=(t=>{let e,s=0,i=1/0;for(let n=t.right;n!==t;n=n.right){if(0===n.rowCount)return n;if(n.rowCount<i||n.rowCount===i&&n.rowWeight>s){if(0===n.rowCount)return n;e=n,i=n.rowCount,s=n.rowWeight}}return e})(u);if(s){if(0!==s.rowCount){V(s);for(let i=s.down;i!==s;i=i.down){if($.push(i.step),a[i.step[0]+i.step[1]]++,o.add(i.step)){for(let t=i.right;t!==i;t=t.right)V(t);yield*t(e+1);for(let t=i.left;t!==i;t=t.left)Z(t)}o.remove($.pop())}if(Z(s),e===n.length){const t=p.length-u.columnCount,s=u.rowCount,i=f.length-h.columnCount,n={depth:e,maxDepth:v,deadends:l,requirements:t,restrictions:i,options:s};yield[void 0,a,n]}}else if(++l%2317==0){const t=p.length-u.columnCount,s=u.rowCount,i=f.length-h.columnCount,n={depth:e,maxDepth:v,deadends:l,requirements:t,restrictions:i,options:s};yield[void 0,a,n]}}else{const t=$.slice(),s=p.length-u.columnCount,i=u.rowCount,n=f.length-h.columnCount,o={depth:e,maxDepth:v,deadends:l,requirements:s,restrictions:n,options:i};yield[t,a,o]}}(n.length)}const Q=(t=e(9,(t=>t+1)))=>{const i=e(46,(t=>[]));for(let e=0;e<1<<t.length;++e){const n=[];for(let s=0;s<9;++s)e&1<<s&&n.push(t[s]);i[s(n)].push(n.join(""))}return i},X=(t,e)=>{var s=[];if(1===t.length)return[t];for(var i=0;i<t.length;i++)for(var n=t[i],o=X([...t.slice(0,i),...t.slice(i+1)]),r=0;r<o.length;r++){const t=[n,...o[r]];if(e){if(e(t))return t}else s.push(t)}return!e&&s},J=(t,s=(t=>t))=>{const i=e(t.length,(t=>0)),n=[];for(let e=0;e<t.reduce(((t,e)=>t*e),1);++e){const e=s(i);e&&n.push(e);let o=0;for(;o<i.length&&++i[o]>=t[o];)i[o]=0,++o;if(i[i.length-1]===t[t.length-1])break}return n},Y="ABCDEFGHJ",tt=({row:t,col:e})=>`${t},${e}`,et=()=>(t,e,s)=>[`pos${9*t+e}`],st=()=>(t,e,s)=>[`row${Y[t]},${s+1}`],it=()=>(t,e,s)=>[`col${e+1},${s+1}`],nt=()=>(t,e,s)=>[`box${3*~~(t/3)+~~(e/3)+1},${s+1}`],ot=[e(9,(t=>9*t+t)),e(9,(t=>9*++t-t))],rt=(t,e)=>({following:[{row:t,col:e+1},{row:t+1,col:e}],preceding:[{row:t,col:e-1},{row:t-1,col:e}]}),lt=t=>{const e=[...new Set([...t.join("")].sort())],s=[];for(let i=1;i<1<<e.length;++i){let n=[];for(let t=0;t<e.length;++t)i&1<<t&&n.push(e[t]);n.length<=t[0].length&&t.every((t=>n.some((e=>!t.includes(e)))))&&s.push([i,n])}return s.filter((([t,e])=>!s.find((([s,i])=>e!==i&&(t&s)===s)))).map((([t,e])=>e)).sort(((t,e)=>t-e))},at=Q(),ct=(t,s)=>{const i=[...new Set([...s.join("")])].join(""),n=new Set;for(let s=2;s<=t;s++)J(e(s,(t=>i.length)),(t=>{let e="";for(let n=0;n<s;++n)e+=i[t[n]];n.add([...e].sort().join(""))}));const o=[...n].filter((t=>s.every((e=>{let s=t;for(const t of e)s=s.replace(t,"");return s.length>0}))));return o.filter((t=>o.every((e=>e===t||-1===t.indexOf(e)))))},ut=t=>{const e=~~(t/9),s=t%9;return[e,s,3*~~(e/3)+~~(s/3)]};class ht extends Error{}const pt=({items:t},i)=>{const n=t.map((t=>0)),o=t.map((t=>[])),r=t.map((t=>new Set(t.positions.map((t=>{const[e,s]=ut(t);return`${Y[e]}${s+1}`}))))),l=r.map((t=>t.size)),a=t.map((t=>A(t.positions,i).length)),c=e(9,(t=>t+1)).join(""),u=t.map((t=>""));return{add:e=>{const i=e[0]+e[1],h=~~e[2];return t.map(((t,e)=>{if(r[e].has(i)){u[e]+=h,n[e]+=h;const r=n[e];o[e].push(i);const p=o[e].length;if(p===l[e])return t.sum===r;const f=c.replace(new RegExp(`[${u[e]}]`,"g"),""),d=new Set([...u[e]]),m=Math.max(0,a[e]-d.size),g=s([...f.slice(0,m)]),$=Math.max(0,l[e]-p-m),v=g+$,w=9*$+(m?s([...f.slice(-m)]):0);return t.sum>=r+v&&t.sum<=r+w}return!0})).every((t=>t))},remove:e=>{const s=e[0]+e[1],i=~~e[2];t.forEach(((t,e)=>{r[e].has(s)&&(u[e]=u[e].replace(i,""),o[e].pop(),n[e]-=i)}))}}};var ft=Object.freeze({__proto__:null,rows:Y,rowColString:tt,position:et,row:st,column:it,box:nt,classic:()=>(t,e,s)=>[...((t,e,s)=>[`pos${9*t+e}`])(t,e),...st()(t,e,s),...((t,e,s)=>[`col${e+1},${s+1}`])(0,e,s),...((t,e,s)=>[`box${3*~~(t/3)+~~(e/3)+1},${s+1}`])(t,e,s)],diagonal:({orientation:t})=>(e,s,i)=>{const n=9*e+s,o=[];return t&&"both"!==t&&"\\"!==t||ot[0].includes(n)&&o.push(`diag0,${i+1}`),t&&"both"!==t&&"/"!==t||ot[1].includes(n)&&o.push(`diag1,${i+1}`),o},kingsmove:()=>(t,e,s)=>[`kings${t},${e},${t+1},${e+1},${s}`,`kings${t-1},${e-1},${t},${e},${s}`,`kings${t},${e},${t+1},${e-1},${s}`,`kings${t-1},${e+1},${t},${e},${s}`].filter((t=>!t.match(/-|9|10/))).map((t=>`optional:${t}`)),knightsmove:()=>(t,e,s)=>[`knights${t},${e},${t+2},${e+1},${s}`,`knights${t},${e},${t+2},${e-1},${s}`,`knights${t},${e},${t+1},${e+2},${s}`,`knights${t},${e},${t+1},${e-2},${s}`,`knights${t-2},${e+1},${t},${e},${s}`,`knights${t-2},${e-1},${t},${e},${s}`,`knights${t-1},${e+2},${t},${e},${s}`,`knights${t-1},${e-2},${t},${e},${s}`].filter((t=>!t.match(/-|9|10/))).map((t=>`optional:${t}`)),disjointgroups:()=>(t,e,s)=>`disjoint${t%3*3+e%3},${s+1}`,consecutive:(t,e,s)=>(t,e,i)=>{const n=9*t+e,o=((t,e)=>{const s=rt(t,e);return{following:s.following.map(tt).filter((t=>!t.match(/9|10/))),preceding:s.preceding.map(tt).filter((t=>!t.match(/-/)))}})(t,e),r=s.kropki?.items?.filter((t=>"consecutive"===t.type))??[];return[...o.following.filter((t=>!r.some((e=>{const[s,i]=t.split(",");return e.positions.every((t=>[n,9*s+~~i].includes(t)))})))).flatMap((s=>[`consecutive${t},${e},${s},${i+1},${i+2}`,`consecutive${t},${e},${s},${i},${i+1}`])),...o.preceding.filter((t=>!r.some((e=>{const[s,i]=t.split(",");return e.positions.every((t=>[n,9*s+~~i].includes(t)))})))).flatMap((s=>[`consecutive${s},${t},${e},${i+1},${i+2}`,`consecutive${s},${t},${e},${i},${i+1}`]))].map((t=>`optional:${t}`))},oddeven:({items:t})=>(e,s,i)=>{const n=t.filter((({type:t})=>"even"!==t)),o=t.filter((({type:t})=>"even"===t)),r=9*e+s;return(!n.map((t=>t.positions[0])).includes(r)||i%2!=1)&&((!o.map((t=>t.positions[0])).includes(r)||i%2!=0)&&[])},inequality:({items:t})=>(s,i,n)=>{const o=9*s+i;return t.flatMap((({positions:t})=>t[0]===o?0!==n&&e(9-n,(e=>`gt${o},${t[1]},${n},${n+e}`)):t[1]===o?8!==n&&e(n,(e=>`gt${t[0]},${o},${n-(e+1)},${n}`)):[])).map((t=>!1===t?t:`optional:${t}`))},kropki:({negativeConstraint:t,items:s})=>(i,n,o)=>{const r=9*i+n,l=s?.flatMap((({type:t,positions:s},i)=>{if(s.includes(r)){if("consecutive"!==t)return![5,7,9].includes(o+1)&&e(9).filter((t=>![2,.5].includes((t+1)/(o+1)))).map((t=>r===s[0]?[o,t]:[t,o])).map((t=>`kropki2x${i},${t}`));if("consecutive"===t)return e(9).filter((t=>![1,-1].includes(t-o))).map((t=>r===s[0]?[o,t]:[t,o])).map((t=>`kropki1+${i},${t}`))}return[]}))??[];let a=[];if(t){const t=s?.filter((t=>"consecutive"!==t.type)),l=s?.filter((t=>"consecutive"===t.type)),c=rt(i,n);for(const i of Object.values(c).flat().filter((t=>t.row>=0&&t.row<9&&t.col>=0&&t.col<9))){const n=9*i.row+i.col;e(9).forEach((e=>{e+1===1&&o+1===2||e+1===2&&o+1===1?s?.find((({positions:t})=>2===t.length&&t.every((t=>[r,n].includes(t)))))||a.push(n<r?`kropki!,${n},${r},${e+1},${o+1}`:`kropki!,${r},${n},${o+1},${e+1}`):(![5,7,9].includes(o+1)&&[2,.5].includes((e+1)/(o+1))&&(t?.find((({positions:t})=>2===t.length&&t.every((t=>[r,n].includes(t)))))||a.push(n<r?`kropki!,${n},${r},${e+1},${o+1}`:`kropki!,${r},${n},${o+1},${e+1}`)),[1,-1].includes(e-o)&&(l?.find((({positions:t})=>2===t.length&&t.every((t=>[r,n].includes(t)))))||a.push(n<r?`kropki!,${n},${r},${e+1},${o+1}`:`kropki!,${r},${n},${o+1},${e+1}`)))}))}}return[...l,...a].map((t=>!1!==t&&`optional:${t}`))},killercage:({items:t})=>{const e=t.map((t=>{if(!t.sum)return[];const e=at[t.sum].filter((e=>e.length===t.positions.length));var s;return{requiredDigits:[...(s=e.map((t=>new Set(t))),new Set([...s?.[0]??[]].filter((t=>s.slice(1).every((e=>e.has(t)))))))].join(""),missingDigits:"123456789".replace(new RegExp(`[${[...new Set([...e.join("")])]}]`,"g"),""),combos:lt(e)}}));return(s,i,n)=>{const o=9*s+i,r=3*~~(s/3)+~~(i/3);return t.flatMap(((t,l)=>{if(!t.sum)return t.positions?.includes(o)?[`cage${l},${n+1}`]:[];const a=new Set,c=new Set,u=new Set;for(const e of t.positions){const[t,s,i]=ut(e);a.add(t),c.add(s),u.add(i)}if(t.positions.includes(o))return e[l].missingDigits.includes(n+1)?[!1]:[`cage${l},${n+1}`,...e[l].combos.flatMap((t=>t.includes(`${n+1}`)?[`cage${l},${t.join("")}:multiple(${t.length-1})`]:[]))];if(e[l].requiredDigits.includes(`${n+1}`)){if(a.has(s))return[`cage${l},row,${n+1}:multiple(${a.size-1})`];if(c.has(i))return[`cage${l},col,${n+1}:multiple(${c.size-1})`];if(u.has(r))return[`cage${l},box,${n+1}:multiple(${u.size-1})`]}return[]})).map((t=>!1===t?t:`optional:${t}`))}},arrow:({items:t},i)=>{const n=e(t.length,(t=>new Set)),o=t.map(((t,o)=>{const r=t.positions.length-1,l=t.positions.slice(1),a=1===r?1:A(l,i).length,c=[s([..."123456789"].slice(0,a))+(r-a),9],u={},h=[];J(e(r,(t=>9)),(t=>{const e=r+s(t);e>=c[0]&&e<=c[1]&&new Set(t).size>=a&&(u[e]=u[e]??new Set,u[e].add(t.map((t=>t+1)).sort().join("")))}));for(let l in u){const a="123456789".replace(new RegExp("["+[...new Set(u[l])].join("")+"]","g"),""),p=[...ct(r,[...u[l]]).reduce(((s,l)=>(n[o].has(l)||(l.length<r&&(l+=e(r-l.length,(t=>"_")).join("")),X([...l],(e=>{let n=!0;for(let s=1;s<=e.length;++s)for(let o=s+1;o<=e.length;++o)"_"!==e[s-1]&&e[s-1]===e[o-1]&&i[t.positions[s]].includes(t.positions[o])&&(n=!1);n&&s.add(e.join(""))}))),s)),new Set)];p.filter((t=>{const e=t.replace(/_/g,""),i=s([...e]),n=r-e.length;return i+9*n<c[0]||i+n>c[1]})).forEach((t=>n[o].add(t))),h[~~l]={disallowedTerms:a,permutedDigits:p.filter((t=>!n[o].has(t)))}}return h})),r=o.map((t=>[...new Set([...t.map((({disallowedTerms:t})=>t)).join("")])].filter((e=>t.every((({disallowedTerms:t})=>-1!==t.indexOf(e))))).join("")));return(e,s,i)=>{const l=9*e+s,a=[];return t.forEach(((t,e)=>{const s=`arrow${e}`;if(l===t.positions[0]){const n=o[e][i+1];if(!n)return void a.push(!1);if(n.disallowedTerms)for(const o of n.disallowedTerms)if(-1===r[e].indexOf(o))for(let e=0;e<t.positions.length-1;++e)a.push(`${s},${i+1},${e},${o}`);for(const t of n.permutedDigits)a.push(`${s},${i+1},${t}:multiple(${t.replace(/_/g,"").length})`)}else if(t.positions.includes(l)){if(-1!==r[e].indexOf(i+1))return void a.push(!1);for(const o of n[e])o[t.positions.indexOf(l)-1]==i+1&&a.push(`${s},${o}:multiple(${o.replace(/_/g,"").length-1})`);for(const[n,r]of o[e].entries()){if(!r)continue;const e=t.positions.indexOf(l)-1;if(-1===r.disallowedTerms.indexOf(i+1))for(const t of r.permutedDigits)~~t[e]===i+1&&a.push(`${s},${n},${t}:multiple(${t.replace(/_/g,"").length})`);else a.push(`${s},${n},${e},${i+1}`)}}})),a.map((t=>!1===t?t:`optional:${t}`))}},thermo:({items:t})=>(s,i,n)=>{const o=9*s+i;return t.flatMap((({positions:t},s)=>{const i=`thermo${s}`;if(t.includes(o)){const s=t.indexOf(o);return t.flatMap(((o,r)=>n<s||n+(t.length-s)>9?[!1]:s<r?e(n+(r-s),(t=>`${i},${s},${n+1},${r},${1+t}`)):s>r?e(9-n,(t=>`${i},${r},${n+1+t},${s},${n+1}`)):[]))}return[]})).map((t=>!1!==t&&`optional:${t}`))},xv:({negativeConstraint:t,items:s})=>(i,n,o)=>{const r=9*i+n,l=s?s.filter((({type:t})=>"v"!==t)):[],a=s?s.filter((({type:t})=>"v"===t)):[],c=[...a.flatMap(((t,s)=>t.positions.includes(r)?o>3?[!1]:e(4).filter((t=>t+o!==3)).map((e=>r==t.positions[0]?[o,e]:[e,o])).map((t=>`xvv${s},${t}`)):[])),...l.flatMap(((t,s)=>t.positions.includes(r)?e(9).filter((t=>t+o!==8)).map((e=>r==t.positions[0]?[o,e]:[e,o])).map((t=>`xvx${s},${t}`)):[]))];let u=[];if(t){const t=rt(i,n);for(const s of t.preceding.filter((t=>t.row>=0&&t.row<9&&t.col>=0&&t.col<9))){const t=9*s.row+s.col;a?.find((({positions:e})=>2===e.length&&e.every((e=>[r,t].includes(e)))))||(u=[...u,...e(4).filter((t=>t+o===3)).map((e=>`xv!v,${t},${r},${e},${o}`))]),l?.find((({positions:e})=>2===e.length&&e.every((e=>[r,t].includes(e)))))||(u=[...u,...e(9).filter((t=>t+o===8)).map((e=>`xv!x,${t},${r},${e},${o}`))])}for(const s of t.following.filter((t=>t.row>=0&&t.row<9&&t.col>=0&&t.col<9))){const t=9*s.row+s.col;a?.find((({positions:e})=>2===e.length&&e.every((e=>[r,t].includes(e)))))||(u=[...u,...e(4).filter((t=>t+o===3)).map((e=>`xv!v,${r},${t},${o},${e}`))]),l?.find((({positions:e})=>2===e.length&&e.every((e=>[r,t].includes(e)))))||(u=[...u,...e(9).filter((t=>t+o===8)).map((e=>`xv!x,${r},${t},${o},${e}`))])}}return[...c,...u].map((t=>!!t&&`optional:${t}`))},betweenline:({items:t})=>(e,s,i)=>{const n=9*e+s;return t.flatMap(((t,e)=>{const s=[];if(t.positions.length<3)return[];const o=[t.positions[0],t.positions[t.positions.length-1]],r=t.positions.slice(1,-1);if(o.includes(n)){const t=n===o[0];s.push(`between${e},${i+1},${i+1}`),s.push(`between${e},${t?`${i+1},${i}`:`${i},${i+1}`}`),s.push(`between${e},${t?`${i+1},${i+2}`:`${i+2},${i+1}`}`);for(let n=0;n<9;++n){if(i===n||1===Math.abs(i-n))continue;const o=Math.max(i,n),l=Math.min(i,n);for(let a=0;a<9;++a)if(a>=o||a<=l){const o=t?i+1:n+1,l=t?n+1:i+1;for(let t=0;t<r.length;++t)s.push(`between${e},${t},${o},${a+1},${l}:multiple(2)`)}}}else if(r.includes(n)){0!==i&&8!==i||s.push(!1);const t=r.indexOf(n);for(let n=0;n<9;++n)for(let o=0;o<9;++o)if(n!==o&&1!==Math.abs(n-o)){const r=Math.max(n,o),l=Math.min(n,o);(i>=r||i<=l)&&s.push(`between${e},${t},${n+1},${i+1},${o+1}:multiple(2)`)}}return s})).map((t=>!1===t?t:`optional:${t}`))},InvalidPuzzleError:ht,palindrome:({items:t},s)=>(i,n,o)=>{const r=9*i+n;return t.flatMap(((t,i)=>{if(t.positions.includes(r)){const n=t.positions.indexOf(r),l=t.positions.length-1-n;if(n===l)return[];if(s[r].includes(t.positions[l]))throw new ht(`Palindrome positions ${r} and ${t.positions[l]} are peers and cannot have the same value.`);const a=n<l?n:l,c=n<l?t=>t:([t,e])=>[e,t];return e(9).filter((t=>t!==o)).map((t=>`palindrome${i},${a},${c([o+1,t+1]).join(",")}`))}return[]})).map((t=>!1!==t&&`optional:${t}`))},region:({items:t})=>(s,i,n)=>{const o=9*s+i;if(t&&8===t.length&&t.every((t=>9===t.positions?.length))){const s={positions:e(81).filter((e=>!t.some((t=>t.positions?.includes(e)))))};9===s.positions.length&&(t=[...t,s])}return t.flatMap(((t,e)=>t.positions.includes(o)?[`${t.positions.length<9?"optional:":""}region${e},${n+1}`]:[]))},minmax:({items:t})=>(e,s,i)=>{const n=[];for(const[o,r]of t.entries()){const l=rt(e,s),a={preceding:l.preceding.map((({row:t,col:e})=>9*t+e)),following:l.following.map((({row:t,col:e})=>9*t+e))},c=9*e+s;if(c===r.positions[0])if("max"===r.type){0===i&&n.push(!1);for(let e=i+1;e<9;++e){for(const s of a.preceding)t.every((t=>!(r.type===t.type&&s===t.positions[0])))&&n.push(`minmax${o},${s},${c},${e+1},${i+1}`);for(const s of a.following)t.every((t=>!(r.type===t.type&&s===t.positions[0])))&&n.push(`minmax${o},${c},${s},${i+1},${e+1}`)}}else{8===i&&n.push(!1);for(let e=i;e>0;--e){for(const s of a.preceding)t.every((t=>!(r.type===t.type&&s===t.positions[0])))&&n.push(`minmax${o},${s},${c},${e},${i+1}`);for(const s of a.following)t.every((t=>!(r.type===t.type&&s===t.positions[0])))&&n.push(`minmax${o},${c},${s},${i+1},${e}`)}}if(Object.values(a).flat().includes(r.positions[0])){const e=c<r.positions[0]?[c,r.positions[0]]:[r.positions[0],c];if(t.every((t=>!(r.type===t.type&&c===t.positions[0]))))if("max"===r.type){8===i&&n.push(!1),8===i&&n.push(!1);for(let t=i;t>0;--t){const s=c<r.positions[0]?[`${i+1},${t}`]:[`${t},${i+1}`];n.push(`minmax${o},${e.join(",")},${s.join(",")}`)}}else{0===i&&n.push(!1);for(let t=i+1;t<9;++t){const s=c<r.positions[0]?[`${i+1}`,`${t+1}`]:[`${t+1}`,`${i+1}`];n.push(`minmax${o},${e.join(",")},${s.join(",")}`)}}}}return n.map((t=>t?`optional:${t}`:t))},sandwichsum:({items:t})=>(e,s,i)=>{const n=9*e+s,o=[];return t.forEach((({positions:t,sum:e},s)=>{if(null==e)return;const r=t.indexOf(n);if(-1!==r){const n=at[e].filter((t=>!t.match(/[19]/))).sort(((t,e)=>t-e));if(0===n.length)return void o.push(!1);const l=n[0].length,a=n[n.length-1].length,c=Math.ceil(t.length-l+2);if(r>c&&r<t.length-1-c&&(0===i||8===i))return void o.push(!1);if(0===i||8===i){const t=0===i?"9":"1";for(let c=0;c<9;++c)if(c<l||c>a)r-(c+1)>=0&&o.push(`sammy${s},${r-(c+1)},${r},${t},${i+1}`),r+c+1<9&&o.push(`sammy${s},${r},${r+c+1},${i+1},${t}`);else if(1===c){const t=[..."2345678".replace(e,"")];if(r-(c+1)>=0)for(const e of t)o.push(`sammy${s},${r-(c+1)},${r},${e}:multiple(2)`);if(r+c+1<9)for(const e of t)o.push(`sammy${s},${r},${r+c+1},${e}:multiple(2)`)}else{const t=n.filter((t=>t.length===c)),e=[..."2345678"].filter((e=>!t.some((t=>t.includes(e)))));for(const t of e)r-(c+1)>=0&&o.push(`sammy${s},${r-(c+1)},${r},${t}:multiple(2)`),r+c+1<9&&o.push(`sammy${s},${r},${r+c+1},${t}:multiple(2)`);lt(t).forEach((t=>{r-(c+1)>=0&&o.push(`sammy${s},${r-(c+1)},${r},${t.join("")}:multiple(${t.length+1})`),r+c+1<9&&o.push(`sammy${s},${r},${r+c+1},${t.join("")}:multiple(${t.length+1})`)}))}}else for(let t=l;t<=a;++t)if(1===t){const t=[..."2345678".replace(e,"")];if(t.includes(`${i+1}`)&&r-1>=0&&r+1<9)for(const e of t)o.push(`sammy${s},${r-1},${r+1},${e}:multiple(2)`)}else{const e=n.filter((e=>e.length===t));if(e.some((t=>t.includes(`${i+1}`)))){lt(e).forEach((e=>{if(e.includes(`${i+1}`))for(let i=Math.max(0,r-(t+1)),n=i+t+1;n<9;++i,++n)r>i&&r<n&&o.push(`sammy${s},${i},${n},${e.join("")}:multiple(${e.length+1})`)}))}else for(let e=Math.max(0,r-(t+1)),n=e+t+1;n<9;++e,++n)r>e&&r<n&&o.push(`sammy${s},${e},${n},${i+1}:multiple(2)`)}}})),o.map((t=>!1!==t&&`optional:${t}`))},quadruple:({items:t})=>(e,s,i)=>{const n=[],o=9*e+s;for(const[r,l]of t.entries()){const t=[..."123456789"].filter((t=>!l.values.includes(~~t))),a=new Set,c=new Set,u=new Set;for(const t of l.positions){const[e,s,i]=ut(t);a.add(e),c.add(s),u.add(i)}if(l.positions.includes(o))if(l.values.includes(i+1)){if(l.values.length<4)for(const e of t)n.push(`quad${r},${i+1},${e}:multiple(${5-l.values.length})`)}else{if(4===l.values.length){n.push(!1);break}for(const t of l.values)n.push(`quad${r},${t},${i+1}:multiple(${5-l.values.length})`);n.push(`quad${r},${t.join("")}:multiple(${4-l.values.length})`)}else if(l.values.includes(i+1)){const t=3*~~(e/3)+~~(s/3);a.has(e)&&n.push(`quad${r},row,${i+1}:multiple(${a.size-1})`),c.has(s)&&n.push(`quad${r},col,${i+1}:multiple(${c.size-1})`),u.has(t)&&n.push(`quad${r},box,${i+1}:multiple(${u.size-1})`)}}return n.map((t=>!1!==t&&`optional:${t}`))},littlekiller:({items:t},e)=>(t,e,s)=>[],littlekillerChecker:pt,magicsquare:({items:t})=>{const e=["_32","23_","2_8","8_2","_12","21_","47_","_74","_78","87_","69_","_69","4_6","6_4","_36","63_","89_","_98","_14","41_"];return(s,i,n)=>[...t.flatMap(((t,e)=>{const o=9*s+i;return t.positions.includes(o)?[`magic${e},${n+1}`]:[]})),...t.flatMap(((t,o)=>{const r=[],l=9*s+i,a=[[0,1,2],[6,7,8],[0,3,6],[2,5,8]];if(t.positions.includes(l)){const s=t.positions.slice().sort(((t,e)=>t-e)).indexOf(l);if(4===s&&4===n)return[];if(4===s||4!==s&&4===n)return!1;const i=8-s;if([0,2,6,8].includes(s)&&!(n%2)||[1,3,5,7].includes(s)&&n%2)return!1;for(let t=0;t<9;++t)4!==t&&n!==t&&n+t!==8&&(s<i?r.push(`magic${o},${s},${n+1},${i},${t+1}`):r.push(`magic${o},${i},${t+1},${s},${n+1}`));for(let t of a.filter((t=>t.includes(s)))){const i=t.indexOf(s);for(const s of e)n+1===~~s[i]&&r.push(`magic${o},${t.join("")},${s}`)}}return r})).map((t=>!1!==t&&`optional:${t}`))]},renban:({items:t})=>(e,s,i)=>{const n=[];for(const[o,r]of t.entries()){const t=9*e+s;if(r.positions.includes(t)){n.push(`optional:renban${o},${i+1}`);const e=r.positions.indexOf(t),s=r.positions.length,l=Math.min(8,i+s-1),a=Math.max(0,i-s+1);for(let t=0;t<s;++t)if(t!==e){for(let s=0;s<a;++s)e<t?n.push(`optional:renban${o},${e},${i+1},${t},${s+1}`):n.push(`optional:renban${o},${t},${s+1},${e},${i+1}`);for(let s=l+1;s<9;++s)e<t?n.push(`optional:renban${o},${e},${i+1},${t},${s+1}`):n.push(`optional:renban${o},${t},${s+1},${e},${i+1}`)}}}return n},whispers:({items:t})=>(e,s,i)=>{const n=[];for(const[o,r]of t.entries()){const t=9*e+s;if(r.positions.includes(t)){4===i&&n.push(!1);const e=r.positions.indexOf(t),s=r.positions.length,l=Math.min(8,i+4),a=Math.max(0,i-4);for(let t=0;t<s;++t)if(1===Math.abs(t-e))for(let s=0;s<9;++s)4!==s&&s<=l&&s>=a&&(e<t?n.push(`optional:whispers${o},${e},${i+1},${t},${s+1}`):n.push(`optional:whispers${o},${t},${s+1},${e},${i+1}`))}}return n}});class dt{constructor(t,e={rules:null}){this.puzzle=t,this.size=t.size,this._rules=e.rules}static enabled(t){return!0}static parseUrlParams(){return{}}static rules(t={size:9}){return`Normal Sudoku rules apply. Place the digits 1 through ${t.size} in each empty cell. Digits must not repeat within the same row, column, or box.`}get rules(){return this._rules??this.constructor.rules(this)}get peers(){return[]}get units(){return[]}clearCandidates(t,e,s,i){return e}eliminateCandidate(t,e,s,i,n){return!0}conflicts(t){return[]}peersFromUnits(){return this.units.reduce(((t,e)=>e.reduce(((t,s)=>(t[s]=[...t[s]??[],...e.filter((t=>t!==s))],t)),t)),e(this.size**2,(t=>[])))}}class mt extends dt{constructor(t,{items:e,rules:s}){super(t),this.arrows=e,this._rules=s}static urlParams(){return["arrow"]}static label(){return"Arrow"}static parseUrlParams(t,e){return{items:e.arrow.map((e=>({positions:z(t,e)})))}}static validatePositions(t,e){if(!(e.length>1&&e.length<9&&e.every(((s,i)=>0===i||s!==e[0]&&Object.values($(t,s)).includes(e[i-1])))))return"Oops! Arrows need between 2 and 7 cells that are each adjacent to the next."}static rules(t={}){return"The digits along each arrow must sum to the digit in the circled cell. Digits may repeat along an arrow if permitted by other rules."}get rules(){return this._rules??mt.rules(this)}conflicts(t){return this.arrows.reduce(((e,i,n)=>{if(i.positions.length>1){const o=i.positions.length-1,r=i.positions.filter((e=>t[e])).length,l=t[i.positions[0]],a=s(i.positions.slice(1).map((e=>t[e])));if(l){const s=i.positions.every((e=>t[e]));(s&&l!==a||!s&&l<=a+o-r)&&e.push([n,i.positions])}else a+o-r>9&&e.push([n,i.positions])}return e}),[])}clearCandidates(t,e,i){for(const n of this.arrows)if(n.positions?.length>1){const o=n.positions[0],r=n.positions.slice(1);for(const i of r){const n=(t[o]||e[o].slice(-1)[0])-s(r.map((s=>s===i?0:t[s]||e[s][0]))),l=(t[o]||e[o][0])-s(r.map((s=>s===i?0:t[s]||e[s].slice(-1)[0])));e[i]=[...e[i]].filter((t=>~~t>=l&&~~t<=n)).join("")}const l=r.map(((t,e)=>[e,i[t].map((t=>r.indexOf(t))).filter((t=>-1!==t))])).sort((([t,e],[s,i])=>e-i)),a=r.map((s=>t[s]?[t[s]]:e[s])),c=[],u=[];l.forEach((([t,e])=>{let s=0,i=a[t].length-1;for(;e.some((e=>c[e]&&a[t][s]===c[e]));)s++;for(;e.some((e=>u[e]&&a[t][i]===u[e]));)i--;c[t]=a[t][s],u[t]=a[t][i]}));const h=s(c.map((t=>~~t))),p=s(u.map((t=>~~t)));e[o]=[...e[o]].filter((t=>~~t>=h&&~~t<=p)).join("")}return e}}class gt extends dt{constructor(t,{items:e,rules:s}){super(t),this.lines=e,this._rules=s}static urlParams(){return["between"]}static label(){return"Between Line"}static parseUrlParams(t,e){return{items:e.between.map((e=>({positions:z(t,e)})))}}static validatePositions(t,e){if(e.length>2){const s=e[e.length-1];if(e[0]!==s&&e.every(((i,n)=>0===n||i!==e[0]&&(n===e.length-1||i!==s)&&Object.values($(t,i)).includes(e[n-1]))))return}return"Oops! Between lines need at least 3 cells that are each adjacent to the next."}static rules(t={}){return"Cells along lines between two filled circles must have values between those in the circles."}get rules(){return this._rules??gt.rules(this)}conflicts(t){return this.lines.reduce(((e,s,i)=>{const n=[s.positions[0],s.positions[s.positions.length-1]].map((e=>t[e])),o=s.positions.slice(1,-1).map((e=>t[e]));return n.every((t=>t))&&o.some((t=>t&&(t>=Math.max(...n)||t<=Math.min(...n))))&&e.push([i,s.positions]),e}),[])}clearCandidates(t,e,s){for(const{positions:s}of this.lines){if(s.length<3)return e;const i=s[0],[n]=s.slice(-1),o=s.slice(1,-1);t[i]&&!t[n]?e[n]=e[n].replace(new RegExp(`[${t[i]-1}${t[i]}${t[i]+1}]`,"g"),""):t[n]&&!t[i]&&(e[i]=e[i].replace(new RegExp(`[${t[n]-1}${t[n]}${t[n]+1}]`,"g"),""));const r=Math.min(t[i]||e[i][0],t[n]||e[n][0]),l=Math.max(t[i]||e[i].slice(-1)[0],t[n]||e[n].slice(-1)[0]);for(const t of o){for(;e[t][0]<=r;)e[t]=e[t].slice(1);for(;e[t].slice(-1)[0]>=l;)e[t]=e[t].slice(0,-1)}}return e}}class $t extends dt{constructor(t,{rules:e}){super(t),this._rules=e}static urlParams(){return["consecutive"]}static label(){return"Consecutive"}static rules(t={}){return"Orthogonally adjacent cells must not contain consecutive digits."}get rules(){return this._rules??$t.rules(this)}conflicts(t){const s=this.puzzle.constraints.kropki?.items?.filter((({type:t})=>"consecutive"===t))??[];return[[0,e(this.size**2).filter((e=>{const i=v(this.size,e);return Object.values(i).some((i=>t[e]&&t[i]&&!s.some((t=>t.positions.every((t=>[e,i].includes(t)))))&&[-1,1].includes(t[e]-t[i])))}))]]}clearCandidates(t,e){const s=this.puzzle.constraints.kropki?.items?.filter((({type:t})=>"consecutive"===t))??[];return e.forEach(((i,n)=>{for(const i of Object.values(v(this.size,n)))0===t[i]||s.some((t=>t.positions.every((t=>[n,i].includes(t)))))||(e[n]=e[n].replace(t[i]-1,"").replace(t[i]+1,""))})),e}}class vt extends dt{constructor(t,{rules:s,orientation:i="both"}){super(t),this._rules=s,this.orientation=i,this.items=[],"both"!==i&&"\\"!==i||this.items.push({positions:e(this.size,(t=>t*this.size+t)),orientation:"positive"}),"both"!==i&&"/"!==i||this.items.push({positions:e(this.size,(t=>++t*this.size-t)),orientation:"negative"}),this._peers=this.peersFromUnits()}static urlParams(){return["diagonal"]}static label(){return"Diagonals"}static parseUrlParams(t,e){return{orientatiopn:e.diagonal.orientation??"both"}}static featureTemplate(t){return{orientation:{type:"choice",label:"",default:"both",choices:{both:{label:"╳"},"/":{label:"╱"},"\\":{label:"╲"}}}}}get units(){return d(this.items,(({positions:t})=>t))}get peers(){return this._peers}static rules(t={}){return"Digits along diagonals must not repeat."}get rules(){return this._rules??vt.rules(this)}}class wt extends dt{constructor(t,{rules:s}){super(t),this._rules=s,this.sets=e(this.size,(t=>[]));const{rowCols:i="3x3",rows:n=~~i?.replace(/x\d+$/i,""),cols:o=~~i?.replace(/^\d+x/i,"")}=t.constraints.box;for(let t=0;t<this.size;t++)for(let e=0;e<this.size;e++){const s=t%n*o+e%o;this.sets[s].push(t*this.size+e)}this._peers=this.peersFromUnits()}static urlParams(){return["disjoint"]}static label(){return"Disjoint Sets"}static enabled(t){return!!t.constraints.box}get units(){return this.sets}get peers(){return this._peers}static rules(t={}){return"Digits must not repeat at corresponding box positions."}get rules(){return this._rules??wt.rules(this)}}class yt extends dt{constructor(t,{rules:e,items:s}){super(t),this.symbols=s,this._rules=e}static urlParams(){return["ineq"]}static label(){return"Inequality"}static parseUrlParams(t,e){return{items:e.ineq.map((e=>({positions:z(t,e)})))}}static validatePositions(t,e){if(2!==e.length||!Object.values(v(t,e[0])).includes(e[1]))return"Oops! Inequality symbols are placed between 2 orthongonally adjacent cells."}static rules(t={}){return"Cells on either side of the inequality symbol must have values that abide by the indicated relationship."}get rules(){return this._rules??yt.rules(this)}conflicts(t){return this.symbols.reduce(((e,s,i)=>(s.positions.every((e=>t[e]))&&t[s.positions[0]]<t[s.positions[1]]&&e.push([i,s.positions]),e)),[])}clearCandidates(t,e){for(const{positions:[s,i]}of this.symbols)if(void 0!==s&&void 0!==i){const[n,o]=[t[s],t[i]],[r,l]=[e[s],e[i]];e[s]=[...r].filter((t=>~~t>(o||~~l[0]))).join(""),e[i]=[...l].filter((t=>~~t<(n||~~r.slice(-1)[0]))).join("")}return e}}const bt=Q();class Ot extends dt{constructor(t,{rules:s,items:i}){super(t),this.cages=i,this._peers=e(this.size**2,(t=>[])),this._rules=s;for(const t of i)for(const e of t.positions)this._peers[e]=[...new Set([...this._peers[e],...t.positions.filter((t=>t!==e))])]}static urlParams(){return["cage"]}static label(){return"Killer Cage"}static parseUrlParams(t,e){return{items:e.cage.map((e=>({sum:~~e.split(/,/)[0],positions:z(t,e.slice(e.indexOf(",")+1))})))}}static validatePositions(t,e){if(!(e.length>0&&e.length<=9&&e.length===new Set(e).size))return"Oops! Killercages need 1 to 9 cells."}static rules(t={}){return"The digits in a cage must sum to the number printed in its corner. Digits may not repeat within a cage."}get rules(){return this._rules??Ot.rules(this)}get peers(){return this._peers}get units(){return this.cages.filter((t=>t.positions.length===this.size)).map((t=>t.positions))}conflicts(t){return this.cages.reduce(((e,i,n)=>{const o=s(i.positions.map((e=>t[e]))),r=i.positions.every((e=>t[e]));return i.sum&&(r&&i.sum!==o||!r&&i.sum<o)&&e.push([n,i.positions]),e}),[])}clearCandidates(t,e,s){for(const{sum:i,positions:n}of this.cages)if(i&&i<=45){const o=n.length,r=t.filter(((t,e)=>0!==t&&n.includes(e))),l=n.filter((e=>!!t[e])),a=e.filter(((t,e)=>n.includes(e)&&!l.includes(e))).map((t=>[...t||[]].filter((t=>!r.includes(~~t))))),c=bt[~~i]?.filter((t=>t.length===o&&r.every((e=>t.includes(e))))).map((t=>[...t].filter((t=>!r.includes(~~t))).join(""))).filter((t=>M([...new Set([...a.join("")])],[...t]).length===t.length)),u=c?.reduce(((t,e)=>M([...t],[...e])),[..."123456789"]).join("");if(c.length>1&&u.length){const t=n.map((t=>s[t])).reduce(((t,e)=>M(t,e)));for(const s of t)e[s]=e[s].replace(new RegExp(`[${u}]`,"g"),"")}const h=[...new Set([...c.join("")])].sort();for(const t of n)e[t]=[...M(h,[...e[t]])].join("")}return e}}class Et extends dt{constructor(t,{rules:s}){super(t),this._rules=s,this._peers=e(this.size**2,(t=>[]));for(let t=0;t<this.size**2;++t){const{row:e,col:s}=g(this.size,t),i=[[e-1,s],[e+1,s],[e,s-1],[e,s+1],[e-1,s-1],[e+1,s-1],[e+1,s+1],[e-1,s+1]];this._peers[t]=i.filter((([t,e])=>t>=0&&t<this.size&&e>=0&&e<this.size)).map((t=>m(this.size,...t)))}}static urlParams(){return["kings"]}static label(){return"King's Move"}static rules(t={}){return"Digits must not repeat in cells that are a chess king's move apart."}get rules(){return this._rules??Et.rules(this)}get peers(){return this._peers}}class Tt extends dt{constructor(t,{rules:s}){super(t),this._rules=s,this._peers=e(this.size**2,(t=>[]));for(let t=0;t<this.size**2;++t){const e=t%this.size;for(const s of[7,11,17,19])t-s>=0&&(7===s&&this.size-e>2||11===s&&e>1||17===s&&this.size-e>1||19===s&&e>0)&&(this._peers[t].push(t-s),this._peers[t-s].push(t))}}static urlParams(){return["knights"]}static label(){return"Knight's Move"}static rules(t={}){return"Digits must not repeat in cells that are a chess knight's move apart."}get rules(){return this._rules??Tt.rules(this)}get peers(){return this._peers}}class St extends dt{constructor(t,{rules:e,negativeConstraint:s,items:i}){super(t),this.items=i,this.negativeConstraint=s,this._rules=e}static urlParams(){return["double","increment"]}static label(){return"Kropki Dot"}static parseUrlParams(t,e){return{items:[...e.double?e.double.map((e=>({type:"double",positions:z(t,e)}))):[],...e.increment?e.increment.map((e=>({type:"consecutive",positions:z(t,e)}))):[]]}}static validatePositions(t,e){if(2!==e.length||!Object.values(v(t,e[0])).includes(e[1]))return"Oops! Kropki dots are placed between 2 orthongonally adjacent cells."}static rules(t={}){return`A black dot between cells indicates cell values with a 2:1 ratio. A white dot between cells indicates cells with consecutive values. ${t.negativeConstraint?"All":"Not all"} dots are shown.`}get rules(){return this._rules??St.rules(this)}conflicts(t){const e=[];if(this.negativeConstraint)for(const[s,i]of t.entries()){if(!i)continue;const n=Object.values(v(this.size,s));for(const o of n.filter((t=>null!=t))){const n=t[o];n&&(this.items?.some((({positions:t})=>t.length&&t.every((t=>[s,o].includes(t)))))||([-1,1].includes(i-n)||[2,.5].includes(i/n))&&e.push([-1,[s,o]]))}}if(this.items?.length)for(const[s,i]of this.items.entries()){const{type:n,positions:[o,r]}=i;t[o]&&t[r]&&("consecutive"===n&&![-1,1].includes(t[o]-t[r])||"consecutive"!==n&&![2,.5].includes(t[o]/t[r]))&&e.push([s,[o,r]])}return e}clearCandidates(t,e){for(const s of this.items??[])for(const[i,n]of s.positions.entries()){const o=t[n],r=s.positions[(i+1)%2],l=t[r];0===l||o?o||("consecutive"===s.type?e[n]=`${[...e[n]].filter((t=>[...e[r]].some((e=>[1,-1].includes(e-t))))).join("")}`:e[n]=`${[...e[n]].filter((t=>[...e[r]].some((e=>[2,.5].includes(e/t))))).join("")}`):"consecutive"===s.type?e[n]=`${[...e[n]].filter((t=>[1,-1].includes(l-t))).join("")}`:e[n]=`${[...e[n]].filter((t=>[2,.5].includes(l/t))).join("")}`}if(this.negativeConstraint)for(const[s]of e.entries()){const i=t[s],n=v(this.size,s);for(const o of Object.values(n).flat())if(o&&!this.items?.find((t=>t.positions.includes(s)&&t.positions.includes(o)))){const n=t[o];0===n||i||(e[s]=`${[...e[s]].filter((t=>![.5,2].includes(~~t/~~n)&![1,-1].includes(~~t-~~n))).join("")}`)}}return e}}class _t extends dt{constructor(t,{items:e,rules:s}){super(t),this.diagonals=e,this._rules=s}static urlParams(){return["lilkiller"]}static label(){return"Little Killer"}static parseUrlParams(t,e){return{items:e.lilkiller.map((e=>({sum:e.split(/,/)[0],positions:z(t,e.substr(e.indexOf(",")+1))})))}}static validatePositions(t,e){if(![y.DIAGONAL_NEGATIVE,y.DIAGONAL_POSITIVE].some((s=>{const i=x(s,t,{positions:e});return i.length===e.length&&i.every((t=>e.includes(t)))})))return"Oops! Littlekiller needs diagonally adjacent cells that cover the grid from edge to edge."}static rules(t={}){return"Digits along diagonals pointed to by arrows outside the grid must sum to the number listed. Digits may repeat along the diagonal if otherwise allowed by normal Sudoku rules."}get rules(){return this._rules??_t.rules(this)}conflicts(t){return this.diagonals.reduce(((e,i,n)=>(i.positions.every((e=>t[e]))&&~~i.sum!==s(i.positions.map((e=>t[e])))&&e.push([n,i.positions]),e)),[])}}class xt extends dt{constructor(t,{rules:e,items:s}){super(t),this.rows=this.cols=Math.sqrt(this.size),this._rules=e,this.items=s}static enabled(t){return~~Math.sqrt(t.size)===Math.sqrt(t.size)}static validatePositions(t,e){if(9===e.length){const s=new Set(e.map((e=>g(t,e).row))).size,i=new Set(e.map((e=>g(t,e).col))).size;if(3===s&&3===i)return}return"Oops! Magic Squares need a 3 by 3 block of cells."}static label(){return"Magic Square"}static rules(t={}){return"The rows, columns, and diagonals in a magic square must all sum to the same totals."}get rules(){return this._rules??xt.rules(this)}conflicts(t,e){const i=[];for(const[e,n]of this.items.entries()){if(n.positions.some((e=>0===t[e])))continue;const{row:r,col:l}=g(this.size,Math.min(...n.positions)),{byRow:a,byCol:c,byDiag:u}=n.positions.reduce((({byRow:t,byCol:e,byDiag:s},i)=>{const{row:n,col:a}=g(this.size,i),c=n-r;t[c]=t[c]??[],t[c].push(i);const u=a-l;e[u]=e[u]??[],e[u].push(i);const h=c*this.rows+u,p=o(h).on((t=>4==t),(t=>[!0,!0])).on((t=>[0,8].includes(t)),(t=>[!0,!1])).on((t=>[2,6].includes(t)),(t=>[!1,!0])).otherwise((t=>[!1,!1]));return p[0]&&(s[0]=s[0]??[],s[0].push(i)),p[1]&&(s[1]=s[1]??[],s[1].push(i)),{byRow:t,byCol:e,byDiag:s}}),{byRow:[],byCol:[],byDiag:[]});new Set([...a,...c,...u].flatMap((e=>s(e.map((e=>t[e])))))).size>1&&i.push([e,n.positions])}return i}clearCandidates(t,e){const s=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];for(const t of this.items)if(9===t.positions?.length){const i=t.positions;i.sort(((t,e)=>t-e));for(let t=0;t<9;++t){const s=i[t];switch(t){case 4:e[s]=e[s].replace(/[^5]/g,"");break;case 1:case 3:case 5:case 7:e[s]=e[s].replace(/[^1379]/g,"");break;default:e[s]=e[s].replace(/[^2468]/g,"")}}for(let t=0;t<9;++t){if(4===t)continue;const n=i[t];for(const o of s.filter((e=>e.includes(t))))e[n]=[...e[n]].filter((s=>{const n=o.filter((e=>e!==t));return[...e[i[n[0]]]].some((t=>[...e[i[n[1]]]].some((e=>~~s+~~t+~~e==15))))})).join("")}}return e}}class Ct extends dt{constructor(t,{rules:e,items:s}){super(t),this.items=s,this._rules=e}static urlParams(){return["max","min"]}static parseUrlParams(t,e){return{items:[...e.mins?e.min.map((e=>({type:"min",position:z(t,e)[0]}))):[],...e.max?e.max.map((e=>({type:"max",position:z(t,e)[0]}))):[]]}}static rules(t={}){return"Min/max cells must be greater than or less than their orthogonally adjacent neighbors as indicated by the symbols bordering the cell."}get rules(){return this._rules??Ct.rules(this)}conflicts(t){const e=[];return this.items.forEach((({positions:s,type:i},n)=>{const o=s[0];if(t[o]){const s=Object.values(v(this.size,o)).filter((e=>t[e]&&this.items.every((t=>t.positions[0]!==e||t.type!==i))&&("max"===i?t[e]>=t[o]:t[e]<=t[o])));s.length>0&&e.push([n,[o,...s]])}})),e}clearCandidates(t,e){for(const{positions:[t],type:s}of this.items){if(void 0===t)continue;Object.values(v(this.size,t)).forEach((i=>{if(i&&!this.items.filter((t=>t.type===s&&t.positions[0]===i)).length){const n="max"===s?t:i,o="max"===s?i:t;for(;e[n]&&e[n][0]<=e[o][0];)e[n]=e[n].slice(1);for(;e[o]&&e[n].slice(-1)<=e[o].slice(-1);)e[o]=e[o].slice(0,-1)}}))}return e}}class jt extends dt{constructor(t,{rules:e,items:s}){super(t),this.items=s,this._rules=e}static urlParams(){return["odd","even"]}static label(){return"Odd/Even"}static parseUrlParams(t,e){return{items:[...e.odd?e.odd.map((e=>({type:"odd",positions:z(t,e)}))):[],...e.even?e.even.map((e=>({type:"even",positions:z(t,e)}))):[]]}}static validatePositions(t,e){if(1!==e.length)return"Oops! OddEvens are placed on a single cell."}static rules(t={}){return"Cells with a filled circle must be odd. Cells with a filled square must be even."}get rules(){return this._rules??jt.rules(this)}conflicts(t){return this.items.reduce(((e,{type:s,positions:i},n)=>(0===i.length||("even"===s?t[i[0]]&&t[i[0]]%2&&e.push([n,i]):!t[i[0]]||t[i[0]]%2||e.push([n,i])),e)),[])}clearCandidates(t,e){for(const{type:t,positions:[s]}of this.items)void 0!==s&&(e[s]=e[s].replace("even"===t?/[^2468]/g:/[2468]/g,""));return e}}class It extends dt{constructor(t,{items:e,rules:s}){super(t),this.lines=e,this._rules=s}static urlParams(){return["palindrome"]}static label(){return"Palindrome"}static parseUrlParams(t,e){return{items:e.palindrome.map((e=>({positions:z(t,e)})))}}static validatePositions(t,e){if(!(e.length>1&&e.every(((s,i)=>0===i||Object.values($(t,s)).includes(e[i-1])))))return"Oops! Palindromes need at least two cells that are each adjacent to the next."}static rules(t={}){return"Digits along a palindrome line read the same forwards or backwards."}get rules(){return this._rules??It.rules(this)}conflicts(t){return this.lines.reduce(((e,s,i)=>{const n=s.positions.slice(0,Math.trunc(s.positions.length/2)).map(((t,e)=>[t,s.positions[s.positions.length-e-1]])).filter((([e,s])=>t[e]&&t[s]&&t[e]!==t[s]));return n&&e.push([i,n.flat()]),e}),[])}clearCandidates(t,e){for(const{positions:s}of this.lines){const i=s.length;if(i>1)for(const[n,o]of s.slice(0,Math.floor(i/2)).entries()){const r=s[i-n-1],[l,a]=[e[o],e[r]],[c,u]=[t[o],t[r]];e[o]=e[r]=M(c?[`${c}`]:[...l],u?[`${u}`]:[...a]).join("")}}return e}}class zt extends dt{constructor(t,{rules:e,items:s}){super(t),this.quadruples=s;for(const t of s)t.values=[...new Set(t.values?.join("").replace(/\s/g,""))].slice(0,4).sort().map((t=>Number(t)));this._rules=e}static urlParams(){return["quad"]}static label(){return"Quadruple"}static parseUrlParams(t,e){return{items:e.quad.map((e=>({values:[...e.split(/,/)[0]].map((t=>~~t)),positions:z(t,e.slice(e.indexOf(",")+1))})))}}static validatePositions(t,e){if(4!==[...new Set(e)].length||!e.every((s=>{const i=Object.values($(t,s));return e.filter((t=>t!=s)).every((t=>i.includes(t)))})))return"Oops! Quadruples need 4 adjacent cells."}static rules(t={}){return"Circled digits where four cells meet must be present as values in those four cells."}get rules(){return this._rules??zt.rules(this)}conflicts(t){return this.quadruples.reduce(((e,s,i)=>{const n=s.positions,o=new Set(s.values),r=n.map((e=>t[e])).filter((t=>0!==t));if(r.forEach((t=>o.delete(t))),o.size>4-r.length){const o=n.filter((e=>0!==t[e]&&!s.values.includes(t[e])));e.push([i,0===o.length?n:o])}return e}),[])}clearCandidates(t,e,s){for(const{values:i,positions:[n,o,r,l]}of this.quadruples)if(i){if(4===i.length){const t=i.join("");e[n]=M([...e[n]],t).join(""),e[o]=M([...e[o]],t).join(""),e[r]=M([...e[r]],t).join(""),e[l]=M([...e[l]],t).join("")}else{const s=t.filter(((t,e)=>0!==t&&[n,o,r,l].includes(e))),a=i.filter((t=>!s.includes(t))).join("");s.length+a.length===4&&(e[n]=t[n]?e[n]:M([...e[n]],a).join(""),e[o]=t[o]?e[o]:M([...e[o]],a).join(""),e[r]=t[r]?e[r]:M([...e[r]],a).join(""),e[l]=t[l]?e[l]:M([...e[l]],a).join(""))}for(const[t,a]of s.entries()){const s=i.join("");[n,o,r,l].every((e=>a.includes(e)&&e!==t))&&(e[t]=e[t].replace(new RegExp(`[${s}]`,"g"),""))}}return e}}class Pt extends dt{constructor(t,{items:s}){if(super(t),this.items=[...s],s&&s.length===t.size-1&&s.every((e=>e.positions?.length===t.size))){const i={positions:e(t.size**2).filter((t=>!s.some((e=>e.positions?.includes(t)))))};i.positions.length===t.size&&this.items.push(i)}this._units=this.items.filter((({positions:e})=>e.length===t.size)).map((({positions:t})=>t)),this._peers=e(this.size**2,(t=>[]));for(const t of this.items)for(const e of t.positions)this._peers[e]=[...new Set([...this._peers[e],...t.positions.filter((t=>t!==e))])]}static label(){return"Region"}static validatePositions(t,e){if(!(e.length>0&&e.length<=9&&e.length===new Set(e).size))return"Oops! Regions need 1 to 9 cells."}static rules(t={}){return t.puzzle.constraints.box?"Digits may not repeat within any of the indicated regions.":`Place the digits 1 through ${t.size} in each empty cell. Digits must not repeat within the same row, column, or indicated region.`}get rules(){return this._rules??Pt.rules(this)}get units(){return this._units}get peers(){return this._peers}}class At extends dt{static label(){return"Renban Line"}constructor(t,{defaults:s,rules:i,items:n}){super(t,{defaults:s}),this.items=n,this._rules=i,this._peers=e(this.size**2,(t=>[]));for(const t of n)for(const e of t.positions)this._peers[e]=[...new Set([...this._peers[e],...t.positions.filter((t=>t!==e))])]}static validatePositions(t,e){if(!(e.length>1&&e.length<=9&&e.every(((s,i)=>0===i||s!==e[0]&&Object.values($(t,s)).includes(e[i-1])))))return"Oops! Renban Lines need between 2 and 9 cells that are each adjacent to the next."}static rules(t={}){return"Digits along each renban line must be a set of consecutive digits in any order, and must not repeat."}get rules(){return this._rules??At.rules(this)}get peers(){return this._peers}get units(){return this.items.filter((t=>t.positions.length===this.size)).map((t=>t.positions))}conflicts(t){return this.items.reduce(((e,s,i)=>{const n=s.positions.filter(((e,i)=>t[e]&&s.positions.some(((i,n)=>t[i]&&Math.abs(t[e]-t[i])>s.positions.length-1))));return n.length&&e.push([i,n]),e}),[])}clearCandidates(t,e){for(const s of this.items){if(!s.positions)continue;const i=s.positions.length;for(const n of s.positions){const o=t[n]||e[n][0],r=t[n]||e[n].slice(-1)[0],l=new RegExp(`[${[..."123456789"].filter((t=>~~t<~~o-i-1||~~t>~~r+i-1)).join("")}]`,"g");for(const t of s.positions)t!==n&&(e[t]=e[t].replace(l,""))}}return e}}class Mt extends dt{constructor(t,{items:e,rules:s}){super(t),this.sums=e,this._rules=s}static urlParams(){return["sammy"]}static label(){return"Sandwich Sum"}static parseUrlParams(t,e){return{items:e.sammy.map((e=>({sum:e.split(/,/)[0],positions:z(t,e.substr(e.indexOf(",")+1))})))}}static validatePositions(t,e){if(![y.COLUMN,y.ROW].some((s=>{const i=x(s,t,{positions:[e[0]]});return i.length===e.length&&i.every((t=>e.includes(t)))})))return"Oops! Sandwich Sum needs an entire row or column of cells."}static rules(t={}){return"Clues outside the grid show the sum of digits sandwiched between the 1 and the 9 in that row or column."}get rules(){return this._rules??Mt.rules(this)}conflicts(t){return this.sums.reduce(((e,i,n)=>{if(i.positions.length<9)return e;const o=i.positions.map((e=>t[e])),r=o.findIndex((t=>1===t)),l=o.findIndex((t=>9===t));if(-1!==r&&-1!==l){const t=Math.min(r,l),a=Math.max(r,l),c=o.slice(t+1,a);c.every((t=>0!==t))&&s(c)!==~~i.sum&&e.push([n,i.positions.slice(t+1,a)])}return e}),[])}}class Nt extends dt{constructor(t,{rules:s,items:i}){super(t),this._rules=s,this.thermos=i,this._peers=e(this.size**2,(t=>[]));for(const t of i)for(const e of t.positions)this._peers[e]=[...new Set([...this._peers[e],...t.positions.filter((t=>t!==e))])]}static urlParams(){return["thermo"]}static label(){return"Thermo"}static parseUrlParams(t,e){return{items:e.thermo.map((e=>({positions:z(t,e)})))}}static validatePositions(t,e){if(!(e.length>1&&e.length<=9&&e.every(((s,i)=>0===i||s!==e[0]&&Object.values($(t,s)).includes(e[i-1])))))return"Oops! Thermos need between 2 and 9 cells that are each adjacent to the next."}static rules(t={}){return"Digits along each thermometer must increase starting from the bulb end."}get rules(){return this._rules??Nt.rules(this)}get peers(){return this._peers}get units(){return this.thermos.filter((t=>t.positions.length===this.size)).map((t=>t.positions))}conflicts(t){return this.thermos.reduce(((e,s,i)=>{const n=s.positions.filter(((e,i)=>t[e]&&s.positions.some(((s,n)=>t[s]&&i<n?t[e]>=t[s]:i>n&&t[e]<=t[s]))));return n.length&&e.push([i,n]),e}),[])}clearCandidates(t,e){for(const s of this.thermos){let i=1;for(const n of s.positions){const s=e[n][0];i=Math.max(i,t[n],s);let o=e[n],r=o?.[0]??i;for(;o&&r<i;)o=o.replace(r,""),r=o?.[0]??i;e[n]=o,++i}let n=9;for(const i of[...s.positions].reverse()){const s=~~e[i].slice(-1);n=Math.min(n,t[i]||9,s);let o=e[i],r=~~o?.slice(-1)??n;for(;o&&r>n;)o=o.replace(r,""),r=~~o?.slice(-1)??n;e[i]=o,--n}}return e}}class Rt extends dt{static label(){return"German Whispers"}constructor(t,{defaults:e,rules:s,items:i}){super(t,{defaults:e}),this.items=i,this._rules=s}static validatePositions(t,e){if(!(e.length>1&&e.length<=9&&e.every(((s,i)=>0===i||s!==e[0]&&Object.values($(t,s)).includes(e[i-1])))))return"Oops! German Whispers need 2 or more cells that are each adjacent to the next."}static rules(t={}){return"Adjacent digits along each german whisper line must have a difference of at least 5."}get rules(){return this._rules??Rt.rules(this)}conflicts(t){return this.items.reduce(((e,s,i)=>{const n=s.positions.filter(((e,i)=>t[e]&&s.positions.some(((s,n)=>1===Math.abs(i-n)&&t[s]&&Math.abs(t[e]-t[s])<5))));return n.length&&e.push([i,n]),e}),[])}clearCandidates(t,e){for(const s of this.items)if(s.positions)for(const[i,n]of s.positions.entries()){const o=t[n]||e[n][0],r=t[n]||e[n].slice(-1)[0],l=new RegExp(`[${[..."123456789"].filter((t=>~~t<5+~~o&&~~t>~~r-5)).join("")}]`,"g");for(const[t,n]of s.positions.entries())1===Math.abs(t-i)&&(e[n]=e[n].replace(l,""))}return e}}class Ut extends dt{constructor(t,{rules:e,negativeConstraint:s,items:i}){super(t),this.items=i,this.negativeConstraint=s,this._rules=e}static urlParams(){return["x","v"]}static label(){return"XV"}static parseUrlParams(t,e){return{items:[...e.x?e.x.map((e=>({type:"x",positions:z(t,e)}))):[],...e.v?e.v.map((e=>({type:"v",positions:z(t,e)}))):[]]}}static validatePositions(t,e){if(2!==e.length||!Object.values(v(t,e[0])).includes(e[1]))return"Oops! XVs are placed between 2 orthongonally adjacent cells."}static rules(t={}){return"Adjacent cells connected with an X must sum to 10. Adjacent cells connected with a V must sum to 5. "+(t.negativeConstraint?"Adjacent cells not connected with an X or V must not sum to 5 or 10.":"")}get rules(){return this._rules??Ut.rules(this)}conflicts(t){const e=[];if(this.negativeConstraint)for(const[s,i]of t.entries()){if(!i)continue;const n=Object.values(v(this.size,s));for(const o of n.filter((t=>null!=t))){const n=t[o];n&&(this.items?.some((({positions:t})=>t.length&&t.includes(s)&&t.includes(o)))||[5,10].includes(i+n)&&e.push([-1,[s,o]]))}}return this.items?.reduce(((e,{type:s,positions:i},n)=>{const[o,r]=i;return t[o]&&t[r]&&t[r]+t[o]!==("v"===s?5:10)&&e.push([n,i]),e}),e),e}clearCandidates(t,e){if(this.items)for(const s of this.items)for(const[i,n]of s.positions.entries()){const o=t[n],r=s.positions[(i+1)%2],l=t[r];0===l||o?o||(e[n]=`${[...e[n]].filter((t=>[...e[r]].some((e=>t!==e&&~~e+~~t==("v"===s.type?5:10))))).join("")}`):e[n]=`${[...e[n]].filter((t=>~~t+~~l==("v"===s.type?5:10))).join("")}`}if(this.negativeConstraint)for(const[s]of e.entries()){const i=t[s],n=v(this.size,s);for(const o of Object.values(n).flat())if(o&&!this.items?.find((t=>t.positions.includes(s)&&t.positions.includes(o)))){const n=t[o];0===n||i||(e[s]=`${[...e[s]].filter((t=>![5,10].includes(~~t+~~n))).join("")}`)}}return e}}const kt=new Map([["arrow",mt],["betweenline",gt],["box",class extends dt{constructor(t,{rules:s,rowCols:i="3x3",rows:n=~~i?.replace(/x\d+$/i,""),cols:o=~~i?.replace(/^\d+x/i,"")}){super(t,{rules:s}),this.rows=n,this.cols=o,this.boxes=e(this.size,(t=>[]));for(let t=0;t<this.size;t++)for(let e=0;e<this.size;e++){const s=Math.trunc(t/n)*n+Math.trunc(e/o);this.boxes[s].push(t*this.size+e)}this._peers=this.peersFromUnits()}get units(){return this.boxes}get peers(){return this._peers}}],["column",class extends dt{constructor(t){super(t),this.columns=e(this.size,(t=>e(this.size,(e=>t+this.size*e)))),this._peers=this.peersFromUnits()}get units(){return this.columns}get peers(){return this._peers}}],["consecutive",$t],["diagonal",vt],["disjointgroups",wt],["gutter",class extends dt{static enabled(){return!0}static gutter(){return!0}static layer(){return 1}renderSvg(){}}],["inequality",yt],["killercage",Ot],["kingsmove",Et],["knightsmove",Tt],["kropki",St],["littlekiller",_t],["magicsquare",xt],["minmax",Ct],["oddeven",jt],["palindrome",It],["quadruple",zt],["region",Pt],["renban",At],["row",class extends dt{constructor(t){super(t),this.rows=e(this.size,(t=>e(this.size,(e=>t*this.size+e)))),this._peers=this.peersFromUnits()}get units(){return this.rows}get peers(){return this._peers}}],["sandwichsum",Mt],["thermo",Nt],["whispers",Rt],["xv",Ut]]),Dt=(t,e,s)=>f((t=>Object.fromEntries(Object.entries(t.constraints).map((([t,e])=>[kt.get(t),t,e])).filter((([t])=>!!t)).map((([e,s,i])=>[s,new e(t,i)]))))(t),e,s),Lt=(t,e)=>{Dt(t,((t,s,i,n)=>{e(s,i,n)}))},Ht={STATUS:"status",COUNT:"count",DEADENDS:"deadends",DEPTH:"depth",MAXDEPTH:"maxDepth",REQUIREMENTS:"requirements",RESTRICTIONS:"restrictions",OPTIONS:"options"},Ft=Object.values(Ht),Bt=Object.fromEntries(Object.values(Ht).map((t=>[t,Ft.indexOf(t)]))),qt="ABCDEFGHJ",Wt=[...qt].reduce(((t,e,s)=>(t[e]=9*s,t)),{}),Gt=(t,s,i,n,o,r,l,a,c=(t=>!1))=>{Ft.forEach(((t,e)=>Atomics.store(r,e,"status"===t?2:0))),o.fill(0),n.fill(0);try{const u=Object.entries(i).filter((([t])=>kt.has(t)&&t in ft)).map((([t,e])=>ft[t](e,s,i))),h=(t,e,s)=>`${qt[t]}${e+1}=${s+1}`;u.unshift(((t,e,s)=>[`pos${9*t+e}`]));let p=Object.fromEntries(e(9,(t=>e(9,(s=>e(9,(e=>[h(t,s,e),u.flatMap((i=>i(t,s,e)))])))).flat())).flat().filter((([,t])=>!t.includes(!1))));const f="littlekiller"in i?pt(i.littlekiller,s):void 0,d=t.reduce(((t,e,s)=>{if(0!==e){const i=~~(s/9),n=s%9;t.push(h(i,n,e-1))}return t}),[]),m=[...new Set(Object.values(p).flat())],g=m.length,$=m.filter((t=>t.match(/^optional:|:multiple\(\d+\)$/))).length,v=g-$,w=Object.values(p).length;let y={count:0,status:2},b=0;const O=K(p,d,f,a),E=Date.now(),T=e(81,(t=>0)),S=t=>{const e=Date.now();for(;Date.now()-e<500;){const t=O.next();if(t.done)return Atomics.store(r,Bt[Ht.STATUS],6),Atomics.store(r,Bt[Ht.DEADENDS],y.deadends),y.status=6,c(y),void clearInterval(S);{const[e,s,i]=t.value;y={...y,...i};const a=Date.now(),u=a-E,h=a-b;if(e&&(++y.count,e.forEach((t=>{T[Wt[t[0]]+(t[1]-1)]=~~t[2]})),n.set(T,(y.count-1)%25e3*81),Atomics.store(r,Bt[Ht.COUNT],y.count)),y.count>=l.solutionLimit||h>100){o.set(Object.values(s),0),Ft.forEach(((t,e)=>{Atomics.store(r,e,y[t])})),b=a,y.status=y.count>=l.solutionLimit?5:u>l.timeLimitMs?3:2;if(2!==y.status)return Atomics.store(r,Bt[Ht.STATUS],y.count>=l.solutionLimit?5:3),c(y),clearTimeout(Gt.timeout),void delete Gt.timeout;c(y)}}}Gt.timeout=setTimeout(S)};return Gt.timeout=setTimeout(S),{startTime:E,optionCount:w,requirementCount:v,restrictionCount:$}}catch(t){return setTimeout(c,100,{status:6,count:0}),console.error(t),{}}};"Atomics"in self||(self.Atomics={store:(t,e,s)=>t[e]=s,load:(t,e)=>t[e]});const Vt="CONTRADICTION",Zt="SOLUTION_COMPLETE",Kt="SOLUTION_INCOMPLETE",Qt="SOLUTION_COMPLETE",Xt="SOLUTION_INCOMPLETE",Jt="SOLUTION_STEP",Yt="SOLUTION_CANCELLED",te="CANDIDATE_ELIMINATION",ee=(t,s,i,n,o,r,l=300,a,c=(t=>!0))=>{let u=0;let h=5;const p=p=>{let d=!0;if(u++<l){const l=q(o,t,s,n,i,(e=>(d=d&&c({type:Jt,gridIteration:a,proceed:d,data:[e]}),d=d&&ne(e,t,s,i,o,c),d=d&&ne({type:te},t,s,i,o,c),!1)));if(l.length&&d)return void f();if(H(o,t,s,n,i,l,(e=>(d=d&&c({type:Jt,gridIteration:a,proceed:d,data:[e]}),d=d&&ne(e,t,s,i,o,c),d=d&&ne({type:te},t,s,i,o,c),!1))).length&&d)return void f();if(0===r){const l=((t,s,i,n,o,r)=>{const l=t.size,a=[],c=e(t.size**2,(t=>[]));for(const[t,e]of Object.entries(n))for(const[s,i]of e.entries())for(const e of i)c[e].push({unitType:t,unitIndex:s,unit:i});const u=Object.keys(n),h=e(l,(t=>Object.fromEntries(u.map((t=>[t,e(l,(t=>[]))]))))),p=e(l,(t=>[]));for(const[t,e]of i.entries())if(0===s[t])for(let s=0;s<l;++s)e.includes(s+1)&&(p[s].push(t),c[t].forEach((({unitType:e,unitIndex:i})=>{h[s][e][i].push(t)})));const f=e(l,(t=>u.flatMap((e=>h[t][e].reduce(((t,s,i)=>(2==s.length&&t.push({type:e,index:i,positions:s}),t)),[])))));for(const[t,s]of f.entries()){const i=e(l**2,(t=>[]));for(const t of s){const[e,s]=t.positions;i[e].push(t),i[s].push(t)}const n=new Map,c=[];for(const[s,u]of i.entries()){const u=e(l**2,(t=>-1)),h=(e,s=0,o=-1,r=[])=>{c[e]=!0;const l=i[e];if(l.length&&(r.push([o,e,s,t]),!n.has(e)))if(-1!==u[e])-1!==o&&u[e]!==s&&n.set(e,r.slice());else if(l.length){u[e]=s;const t=(s+1)%2;for(const s of l)s.positions[0]===e&&s.positions[1]!==o?r=h(s.positions[1],t,e,r):s.positions[1]===e&&s.positions[0]!==o&&(r=h(s.positions[0],t,e,r))}return r};if(!c[s]){const i=h(s);for(const s of p[t]){const n=o[s].map((t=>({peer:t,color:u[t]}))).reduce(((t,{peer:e,color:s})=>(-1!==s&&t[s].push(e),t)),e(2,(t=>[]))),l=u[s];if(-1===l){if(n[0].length&&n[1].length){const e={type:R,positions:[...n[0],...n[1]],values:[t+1],impactedPositions:[s],chain:[i]};if(a.push(e),!r(e))return a}}else if(n[l].length){const e=i.reduce(((t,[,e,i])=>(i===l&&e!==s&&t.push(e),t)),[]),n={type:N,positions:[s],values:[t+1],impactedPositions:e,chain:[i]};if(a.push(n),!r(n))return a}}}}}return a})(o,t,s,n,i,(e=>(d=d&&c({type:Jt,gridIteration:a,proceed:d,data:[e]}),d=d&&ne(e,t,s,i,o,c),d=d&&ne({type:te},t,s,i,o,c),!1)));if(l.length&&d)return void f();const u=((t,s,i,n,o,r,l,a,c,u)=>{if(r>0)return[];const h=e(t.size**2).sort(((t,e)=>i[t].length-i[e].length));let p;for(let f=h.findIndex((t=>i[t].length>1));f<i.length;++f){const d=h[f];if(-1!==f&&i[d].length<=9){for(const h of i[d]){const f=[...i],m=[...s];f[d]=h;const g=[];c(m,f,o,n,t,r+1,l,a,(t=>{const s=Object.entries(n).reduce(((t,[s,i])=>i.reduce(((t,i,n)=>(t.push([s,n,i.reduce(((t,e)=>(0!==m[e]&&(t[m[e]-1]=!0),[...f[e]].forEach((e=>t[e-1]=!0)),t)),e(9,(t=>!1))).map(((t,e)=>t?"":e+1)).join("")]),t)),t)),[]);return g.push(t),!!([Kt,Zt].includes(t.type)||!s.some((([t,e,s])=>s.length))&&t.proceed)||(p={type:Vt,n:1,positions:[d],impactedPositions:f.map(((t,e)=>0===t.length?e:void 0)).filter((t=>t)),values:[h],steps:g.map((t=>t.data[0])),impactedUnits:s.filter((([t,e,s])=>s.length))},u(p),!1)}))}if(p)return[p]}}return[]})(o,t,s,n,i,r,h,a,ee,(e=>(d=d&&ne(e,t,s,i,o,c),d=d&&c({type:Jt,gridIteration:a,data:[e]}),d=d&&ne({type:te},t,s,i,o,c),!1)));if(u.length&&d)return h=2,void f();if(t.includes(0)&&h++<10&&d)return void f()}}c({type:t.includes(0)?Xt:Qt,gridIteration:a})},f=0===r?t=>setTimeout(p):p;f()},se=(t,e,s,i,n,o,r)=>(s[e]=~~t,i[e]=t,n[e].forEach((e=>i[e]=i[e].replace(t,""))),i),ie=(t,e,s,i,n,o,r)=>{if(!t||0===e.length)return i;for(const s of e)i[s]=i[s].replace(new RegExp(`[${t}]`,"g"),"");return i},ne=(t,e,s,i,n,o)=>{switch(t.type){case"SUDOKU_SOLVER_STEP":for(const[n,o]of Object.entries(t.assignments))for(const t of o)se(n,t,e,s,i);for(const[e,i]of Object.entries(t.eliminations))ie(`${e}`,i,0,s);break;case F:case B:if(1===t.n)se(t.values[0],t.positions[0],e,s,i);else{const e="123456789".replace(new RegExp(`[${t.values.join("")}]`,"g"),"");ie(e,t.positions,0,s),ie(t.values.join(""),t.impactedPositions,0,s)}break;case U:case R:case N:ie(t.values.join(""),t.impactedPositions,0,s);break;case Vt:ie(t.values.join(""),t.positions,0,s);break;case te:if(!((t,e,s,i,n)=>{let o;const r={};do{o=e.join(""),Lt(i,((i,n)=>{if(!["row","box","column","ellipse","rectangle","path","text"].includes(n)){const o=[...e];i.clearCandidates(t,e,s),r[n]=r[n]||{},o.forEach(((t,s)=>{const i=t.replace(new RegExp(`[${e[s]}]`,"g"),"");if(i)for(let t of[...i])r[n][t]=r[n][t]||[],r[n][t].push(s)}))}}))}while(e.every((t=>t.length))&&o!==e.join(""));for(const t in r)0===Object.keys(r[t]).length&&delete r[t];if(Object.keys(r).length>0)return n({type:Jt,gridIteration:0,proceed:!0,data:[{type:te,constraints:r}]});return!0})(e,s,i,n,o))return!1}return s.every((t=>t.length>0))},oe="LOGICAL_WORKER",re="BRUTE_FORCE_WORKER",le="INITIALIZE_BUFFERS",ae="INITIALIZE_PUZZLE",ce="SEARCH_INITIATION",ue="SOLVE",he="CANCEL_SOLVE",pe="SOLVE_BRUTE_FORCE",fe="CANCEL_BRUTE_FORCE",de="SOLUTION_COUNT";let me=!1;const ge="SharedArrayBuffer"in self;class $e{puzzle={};constructor(){addEventListener("message",(t=>{switch(t.data.type){case le:t.data.workerType===re&&this.initializeBuffers(t.data);break;case ae:this.initializePuzzle(t.data);break;case ue:t.data.workerType===oe&&(me=!1,this.logicalSolve(t.data.values,t.data.candidates,this.peers,this.units,this.puzzle,t.data.gridIteration));break;case he:t.data.workerType===oe&&(me=!0,postMessage({type:Yt}));break;case pe:t.data.workerType===re&&this.solveBruteForce(t.data);break;case fe:t.data.workerType===re&&this.cancelBruteForce(t.data)}}))}initializeBuffers({buffer:t,bufferParams:{solutions:e,header:s}}){this.bufferParams={solutions:e,header:s},this.buffer=ge?t:new ArrayBuffer(4*s+324+81*e),this.header=new Uint32Array(this.buffer,0,s),this.heatmap=new Uint32Array(this.buffer,4*s,81),this.solutions=new Uint8Array(this.buffer,4*s+324,81*e)}initializePuzzle({puzzle:t,units:e,peers:s}){this.puzzle=t,this.units=e,this.peers=s}logicalSolve(t,e,s,i,n,o){return ee(t,e,s,i,n,0,300,o,(t=>(postMessage(t),!me)))}lastBruteForceCount;lastBruteForceIteration;solveBruteForce({values:t,peers:e,puzzle:s,gridIteration:i,settings:n}){this.cancelBruteForce(),this.lastBruteForceCount=0,this.lastBruteForceIteration=i,this.lastReport=Date.now(),this.reportInterval=100;const o=n.randomize?Date.now():0;let r=!1;const l=Gt(t,e,s.constraints,this.solutions,this.heatmap,this.header,n,o,(t=>{const e=Date.now();r=2!==t.status,(e-this.lastReport>this.reportInterval||r)&&this.postSolutionCount(t,r,i),this.lastBruteForceCount=t.count,this.lastBruteForceIteration=i}));r||postMessage({type:ce,data:{...l,gridIteration:i}})}postSolutionCount(t,e,s){let i=this.buffer;if(!ge){const e=t.count-this.lastBruteForceCount;i=new ArrayBuffer(4*this.bufferParams.header+324+81*e);const s=new Int32Array(i,0,this.bufferParams.header),n=new Uint32Array(i,4*this.bufferParams.header,81),o=new Uint8Array(i,4*this.bufferParams.header+324,81*e);if(s.set(this.header),n.set(this.heatmap),this.lastBruteForceCount!==t.count){const t=this.lastBruteForceCount%this.bufferParams.solutions,s=(t+e)%this.bufferParams.solutions;o.set(this.solutions.slice(81*t,s<t?this.solutions.length-1:81*s),0),s<t&&o.set(this.solutions.slice(0,81*s),81*(this.bufferParams.solutions-t))}}ge?postMessage({type:de,gridIteration:s,data:{stats:t}}):postMessage({type:de,gridIteration:s,data:{stats:t},buffer:i},[i])}cancelBruteForce(){Gt.timeout&&(clearTimeout(Gt.timeout),Atomics.store(this.header,Bt[Ht.STATUS],4),this.postSolutionCount({count:this.header[Bt[Ht.COUNT]],status:4},!0,this.lastBruteForceIteration))}}return new $e,t.BRUTE_FORCE_WORKER=re,t.CANCEL_BRUTE_FORCE=fe,t.CANCEL_SOLVE=he,t.FINDINGS="FINDINGS",t.INITIALIZE_BUFFERS=le,t.INITIALIZE_PUZZLE=ae,t.LOGICAL_WORKER=oe,t.SEARCH_INITIATION=ce,t.SOLUTION_CANCELLED=Yt,t.SOLUTION_COMPLETE=Qt,t.SOLUTION_COUNT=de,t.SOLUTION_INCOMPLETE=Xt,t.SOLUTION_STEP=Jt,t.SOLVE=ue,t.SOLVE_BRUTE_FORCE=pe,t.STATS=Ht,t.STATS_BY_OFFSET=Ft,t.STATS_OFFSETS=Bt,t.STATUS_ABANDONED=3,t.STATUS_CANCELLED=4,t.STATUS_COMPLETED=6,t.STATUS_COUNTING=2,t.STATUS_EXHAUSTED=5,t.STATUS_IDLE=0,t.STATUS_INITIALIZING=1,t.SudokuWorker=$e,Object.defineProperty(t,"__esModule",{value:!0}),t}({});
